# java基础

## 基础

###  版本

- Java SE（标准版）
- Java EE（企业版）
- Java ME（微缩版）

###  语言特点

- 面向对象(使用计算机模拟现实世界,解决现实题,贴近人类思维模式)
- 筒单(相对C、C+、C#,不易造成内存溢出、滅少代码量、代码可读性强)
- 跨平台(操作系统、服务器、数据库)
- 可靠性
- 安全性
- 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；
- 编译与解释并存

###  运行机制

.java源程序——编译器——.class字节码——解析器——机械码——计算机

### 环境搭建

- JDK（java development kit）
  开发环境，包含JRE+类库+开发工具包（编译器+调试工具）
- JRE（java runtime environment）
  运行环境，包含：JVM和解释器
- JVM（java virtual machine）
  不同的操作系统中，模拟相同的环境

## 语法

#### 语言基础

#####  变量

- 第一种声明方式——先声明后赋值
  数据类型   变量名;
  `Int age;//开辟整数変量空间`
  変量名=值
  `age=18;/将整数值赋给変量`
- 第二种声明方式——声明并赋值
  `int age = 18；`
- 第三种声明方式——多个同类型变量的声明并赋值
  `int x,y,z = 11,12,13;`
- 注意:Java是强类型语言,変量的类型必须与数据的类型一致。
- 声明一个变量后，必须用赋值语句对变量进行显式初始化

#####  常量

```
# 常量名一般使用大写字符
final 常量名=值;
final double PI=3.14; 
final String LOVE="imooc";
```

##### 运算符

###### 赋值运算符

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194703.png)

###### 算术运算符	

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194724.png)

###### 关系运算符

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194747.png)

###### 逻辑运算符	

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194804.png)

###### 位运算符

与（&）、非（~）、或（|）、异或（^）

###### 移位运算符

<<    :   左移运算符，num << 1,相当于num乘以2

\>>    :   右移运算符，num >> 1,相当于num除以2

\>>>   :   无符号右移，忽略符号位，空位都以0补齐

###### 三目运算符

格式
` 布尔表达式?结果1:结果2    //布尔表达式为真，则结果1，布尔表达式为假，则结果2` 

```
public static void main(String[] args) {
	int age = 18;
	String age1=age == 17?"成年了":"未成年";
	System.out.println(age1);
	int x = 10;
	int y = 5;
	int z;
	z = (x > y) ? x : y;//三目运算符
		/*if (x>y){
			z = x;
		}else {
			z = y;
		}*/
	System.out.println("z = " + z);
	}
}
```

###### 转义运算符

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211114_220021.png)

```
System.out.println("xx\tx\t");
System.out.println("y\nyy");
System.out.println("\\");
System.out.println("\"");
System.out.println("\'");
System.out.println("\rzzz");
```

##### 数据类型

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194820.png)

###### 数据类型转换

- 自动类型转换

byte->short->char->int->long->float->double

- 强制类型转换

```
public class TypeConversion {
    public static void main(String[] args) {
        short s = 123;
        int i = s;        	// 目标类型大于源类型  自动类型转换 short ---> int
        System.out.println(i);

        double d = i;       // 目标类型大于源类型  自动类型转换 int ---> double
        System.out.println(d);

        short num = 123;
        byte target = (byte) num;       // 目标类型小于源类型  强制类型转换 short ---> byte
        System.out.println(target);

        double x = 12.34;
        int y = (int) x;            // 目标类型小于源类型  强制类型转换 double ---> int
        System.out.println(y);

        short m = 258;
        byte n = (byte) m;      // 目标类型小于源类型  强制类型转换 short ---> byte
        System.out.println(n);

        int a = -65;
        char b = (char) a;      // 目标类型小于源类型  强制类型转换 int ---> char
        System.out.println(b);
    }
}
```

- 字符串转为Int类型

```
public class StringChangeToInt {
    public static void main(String[] args) {
        // 方式一
        int num = Integer.parseInt("56544");
        // 方式二
        int num2=Integer.valueOf("123");
        System.out.println(num+"  "+num2);
    }
}
```

###### 包装类

Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：

| 基本类型 | 对应的包装类（位于java.lang包中） |
| -------- | --------------------------------- |
| byte     | Byte                              |
| short    | Short                             |
| int      | **Integer**                       |
| long     | Long                              |
| float    | Float                             |
| double   | Double                            |
| char     | **Character**                     |
| boolean  | Boolean                           |

###### Integer类

- Integer类概述

  包装一个对象中的原始类型 int 的值

- Integer类构造方法及静态方法

| 方法名                                  | 说明                                   |
| --------------------------------------- | -------------------------------------- |
| public Integer(int   value)             | 根据 int 值创建 Integer 对象(过时)     |
| public Integer(String s)                | 根据 String 值创建 Integer 对象(过时)  |
| public static Integer valueOf(int i)    | 返回表示指定的 int 值的 Integer   实例 |
| public static Integer valueOf(String s) | 返回保存指定String值的 Integer 对象    |

- 示例代码

```java
public class IntegerDemo {
    public static void main(String[] args) {
        //public Integer(int value)：根据 int 值创建 Integer 对象(过时)
        Integer i1 = new Integer(100);
        System.out.println(i1);

        //public Integer(String s)：根据 String 值创建 Integer 对象(过时)
        Integer i2 = new Integer("100");
		//Integer i2 = new Integer("abc"); //NumberFormatException
        System.out.println(i2);
        System.out.println("--------");

        //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例
        Integer i3 = Integer.valueOf(100);
        System.out.println(i3);

        //public static Integer valueOf(String s)：返回保存指定String值的Integer对象 
        Integer i4 = Integer.valueOf("100");
        System.out.println(i4);
    }
}
```

###### 装箱与拆箱

> https://www.cnblogs.com/dolphin0520/p/3780005.html

基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：

* **装箱**：从基本类型转换为对应的包装类对象。

* **拆箱**：从包装类对象转换为对应的基本类型。

用Integer与 int为例：

基本数值---->包装对象

~~~java
Integer i = new Integer(4);//使用构造函数函数
Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法
~~~

包装对象---->基本数值

~~~java
int num = i.intValue();
~~~

> https://www.cnblogs.com/dolphin0520/p/3780005.html

Integer 例子:

```java
  Integer i1 = 40;
  Integer i2 = 40;
  Integer i3 = 0;
  Integer i4 = new Integer(40);
  Integer i5 = new Integer(40);
  Integer i6 = new Integer(0);
  
  System.out.println("i1=i2   " + (i1 == i2));
  System.out.println("i1=i2+i3   " + (i1 == i2 + i3));
  System.out.println("i1=i4   " + (i1 == i4));
  System.out.println("i4=i5   " + (i4 == i5));
  System.out.println("i4=i5+i6   " + (i4 == i5 + i6));   
  System.out.println("40=i5+i6   " + (40 == i5 + i6));     
```

结果：

```
i1=i2   true
i1=i2+i3   true
i1=i4   false
i4=i5   false
i4=i5+i6   true
40=i5+i6   true
```

解释：

语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。

###### 自动装箱与自动拆箱

由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：

```java
Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);
i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;
//加法运算完成后，再次装箱，把基本数值转成对象。
```

###### 基本类型转换为String

- 转换方式

  * 方式一：直接在数字后加一个空字符串

   - 方式二：通过String类静态方法valueOf()

- 示例代码

```java
public class IntegerDemo {
    public static void main(String[] args) {
        //int --- String
        int number = 100;
        //方式1
        String s1 = number + "";
        System.out.println(s1);
        //方式2
        //public static String valueOf(int i)
        String s2 = String.valueOf(number);
        System.out.println(s2);
        System.out.println("--------");
    }
}
```

  ###### String转换成对应的基本类型 

除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：

- `public static byte parseByte(String s)`：将字符串参数转换为对应的byte基本类型。
- `public static short parseShort(String s)`：将字符串参数转换为对应的short基本类型。
- `public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。
- `public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。
- `public static float parseFloat(String s)`：将字符串参数转换为对应的float基本类型。
- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。
- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的boolean基本类型。

代码使用（仅以Integer类的静态方法parseXxx为例）如：

- 转换方式
  - 方式一：先将字符串数字转成Integer，再调用valueOf()方法
  - 方式二：通过Integer静态方法parseInt()进行转换
- 示例代码

```java
public class IntegerDemo {
    public static void main(String[] args) {
        //String --- int
        String s = "100";
        //方式1：String --- Integer --- int
        Integer i = Integer.valueOf(s);
        //public int intValue()
        int x = i.intValue();
        System.out.println(x);
        //方式2
        //public static int parseInt(String s)
        int y = Integer.parseInt(s);
        System.out.println(y);
    }
}
```

> 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。

#### 流程控制

##### 选择分支

###### if...else...语句

###### switch语句

```
import java.util.Scanner;

public class WeekdaySwitch{
	public static void main(String[] args){	
		//一周计划
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入1-7的数字：");
		int weekDay = sc.nextInt();
		switch(weekDay){
			default:
				System.out.println("录入有误，请输入1~7之间的有效数字！");
				break;
			case 1:
				System.out.println("学习java");
				break;		
			case 2:
			case 5:
			case 6:
				System.out.println("玩游戏");
				break;		
			case 3:
				System.out.println("爬山");
				break;	
			case 4:
				System.out.println("上班");
				break;
			case 7:
				System.out.println("考试");
				break;			
		}	
		System.out.println("结束");		
	}
}
```

##### 循环

###### do...while循环

```
// do ... while循环
	public static void sum2() {
		int i = 0 ;
		int sum = 0;
		do{
			sum = sum + i;
			i++;
		}while(i<101);
		System.out.println(sum);
	}
```

###### while循环

```
// while循环
	public static void sum1() {
		int i = 0 ;
		int sum = 0;
		while(i<101){
			sum = sum + i;
			i++;
		}
		System.out.println(sum);
	}
```

###### for循环

```
// for循环
	public static void sum(){
		int sum = 0;
		for(int i=1;i<101;i++) {
			if(i%2!=0) {
			sum = sum + i;
			}
		}
		System.out.println(sum);
	}	
```

###### foreach 循环 (两个功能：1遍历数组 2 遍历集合）

```
public class ForEachCircular {
    public static void main(String[] args) {
        // foreach循环遍历数组
        String [] names = {"xiao","xian","hua","nian"};
        for(String name:names){
            System.out.print(name + "\t");
        }
        System.out.println();
        // foreach循环遍历集合
        ArrayList<String> ming = new ArrayList<String>();
        ming.add("xiao");
        ming.add("xian");
        ming.add("hua");
        ming.add("nian");
        for(String m:ming){
            System.out.print(m + "\t");
        }
    }
}
```

##### 跳转

###### break语句  :跳出循环

###### continue语句：跳出本次循环

```
public class BreakAndContinue {
    public static void main(String[] args) {
        for (int i = 1; i < 6 ; i++) {
            if (i % 5 ==0){
                break;
            }
            System.out.println("当前循环次数：" + i);
        }
        System.out.println("<--------------------->");
        for (int i = 1; i < 7 ; i++) {
            if (i % 5 ==0){
                continue;
            }
            System.out.println("当前循环次数：" + i);
        }
    }
}
```

####  java数组学习

> https://bbs.huaweicloud.com/blogs/307223

##### 数组的定义

同一种类型数据的集合

```
    // 第一种  数组的定义  定义一个存储3个整数的容器
	int [] x = new int[3];
	// 第二种  数组的定义  定义一个存储3个整数的容器
	int [] y = new int[] {2,7,6,9,4,3,3};
	// 第三种  数组的定义  定义一个存储3个整数的容器
	int [] z = {2,7,6,9,4,3,3};

        // 数组定义，二维数组
	// 第一种  数组的定义  
		int [][] arr4 = new int[3][5];
	// 第二种  数组的定义  
		int [][] arr5 = new int[][] {{-2,7,6},{-9,4,3,3}};
	// 第三种  数组的定义  
		int [][] arr6= {{-2,7,6},{-9,4,3,3}};
```

##### 数组的操作

```
package base;

public class Array_learn {
public static void main(String[] args) {
	// 数组定义，一维数组
	// 第一种  数组的定义  定义一个存储3个整数的容器
	int [] arr1 = new int[3];
	// 第二种  数组的定义  
	int [] arr2 = new int[] {-2,7,6,-9,4,3,3};
	// 第三种  数组的定义  
	int [] arr3= {2,7,6,9,4,3,3};
	
	// 数组定义，二维数组
	// 第一种  数组的定义  
		int [][] arr4 = new int[3][5];
	// 第二种  数组的定义  
		int [][] arr5 = new int[][] {{-2,7,6},{-9,4,3,3}};
	// 第三种  数组的定义  
		int [][] arr6= {{-2,7,6},{-9,4,3,3}};
	
	// 打印数组
	printArray(arr2);
	//获取数组中的最大值
	int max = getArrayMax(arr2);
	System.out.println(max);
	//获取数组中的最小值
	int min = getArrayMin(arr2);
	System.out.println(min);
	// 数组的排序之冒泡排序
	bubbleSort(arr2);
	printArray(arr2);
	// 数组的排序之插入排序
	insertSort(arr2);
	printArray(arr2);
	// 数组的排序之选择排序
	selectSort(arr2);
	printArray(arr2);
	// 数组的查找之折半查找
	// 因为折半查找要求数组必须有序，所以先进行排序
	selectSort(arr2);
	int m = halfSearch(arr2,7);	
	System.out.println(m);	// 返回查找的数组下标，如果没有找到返回-1
	}
	// 打印数组
	public static void printArray(int[] y){
		for(int i =0; i < y.length; i++)
		{
			System.out.print(y[i]+"\t");
		}
		System.out.println();
	}
	// 获取数组中的最大值
	public static int getArrayMax(int[] y){
		int max = y[0];
		for(int i = 0; i < y.length; i++){
			if(y[i]>max){
				max =y[i];
			}
		}
		return max;	
	}
	//获取数组中的最小值
	public static int getArrayMin(int[] y){
		int min = y[0];
		for(int i = 0; i < y.length; i++){
			if(y[i]<min){
				min =y[i];
			}
		}
		return min;	
	}
	// 数组的排序之冒泡排序
	public static void bubbleSort(int[] y) {
		/**
		冒泡排序
		比较相邻的元素。如果第一个比第二个大，就交换他们两个。 [1] 
		对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 [1] 
		针对所有的元素重复以上的步骤，除了最后一个。 [1] 
		持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
		**/
		int temp = 0;
		// 外层循环，它决定一共走几趟
		for (int i = 0; i < y.length-1; ++i) {
		//内层循环，它决定每趟走一次
		for (int j = 0; j < y.length-i-1; ++j) {
		//如果后一个大于前一个  	换位
		if (y[j + 1] < y[j]) {
			temp = y[j];
			y[j] = y[j + 1];
			y[j + 1] = temp;
			}
		}	
	 }
	}
	// 数组的排序之插入排序
	public static void insertSort(int y[]) {
		int i, j;
		for (i = 1; i < y.length; i++) {
		int temp = y[i];
		for (j = i; j > 0 && temp < y[j - 1]; j--) {
		y[j] = y[j - 1];
		}
		y[j] = temp;
		}
		}
	// 数组的排序之选择排序
	public static void selectSort(int y[]) {
		int temp = 0;
		for (int i = 0; i < y.length - 1; i++) {
		// 认为目前的数就是最小的, 记录最小数的下标
		int minIndex = i;
		for (int j = i + 1; j < y.length; j++) {
		if (y[minIndex] > y[j]) {
		// 修改最小值的下标
		minIndex = j;
		}
		}
		// 当退出for就找到这次的最小值
		if (i != minIndex) {
		temp = y[i];
		y[i] = y[minIndex];
		y[minIndex] = temp;
		   }
		}
	}
	// 数组的查找之折半查找
	public static int halfSearch(int[] arr,int target) {
		//定义三个变量分别记录最大、最小、中间的查找范围索引值
		int max=arr.length-1;
		int min=0;
		int mid=(max+min)/2;
		while(true) {	
			if(target<arr[mid]) {		//如果目标元素小于中点元素
				max = mid-1;			//max向mid前移动
			}else if(target>arr[mid]) { //如果目标元素大于中点元素
				min = mid+1;			//min向mid后移动
			}else {
				return mid;				//找到目标元素
			}			
			//没有找到的情况
			if(max<min) {
				return -1;
			}			
			//重新计算中间索引值
			mid=(max+min)/2;
		}		
	}	
}
```

#### Javadoc 使用详解

https://blog.csdn.net/vbirdbest/article/details/80296136

## 面向对象

### 方法

#### 方法的概念

方法就是定义在类中的具有特定功能的一段独立代码（函数==方法）

方法的优点

- 减少代码冗余。
- 提高复用性。
- 提高可读性。
- 提高可维护性。
- 方便分工合作。

#### 方法的定义

```
修饰符 返回值类型 方法名（[参数类型1 参数名1,参数类型2 参数名2 ....]）{
    代码块.......
    return  返回值；    //返回值的类型必须与返回值类型一致
}
```

#### 方法的参数

形参：等同于局部变量
实参：

```
定义语法：
public static void 方法名称(形式参数){
      // 方法主体
}
调用语法
 方法名称(实际参数);
```

#### 方法的返回值与返回值类型

```
定义语法
public static 返回值类型 方法名称(形式参数列表){
        // 函数主体
    return value; // 返回值
}
调用语法
变量 = 方法名称();   // 变量类型与返回值类型一致
```

return关键字

- 用途
  （1）返回方法指定类型的值（前提是方法的返回值类型不是void）。
  （2）方法的结束，它会导致当前的方法退出。
- 使用形式
  （1）方法有返回值类型，格式：
                return 返回值;
  （2）方法没返回值类型，格式：
                return;

#### 方法的重载

在同一个类中，定义多个方法名相同、参数列表不同的方法。
调用时通过方法名和参数列表来确定一个方法,方法的重载和返回值类型无关。

```
public class Function_test {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
            int a = add(4,9);
            System.out.println(a);
            int b = add(4,9,4);
            System.out.println(b);
    }

    // add函数，获取两个值的和
    public static int add(int x,int y){
            int sum = x+y;
            return sum;
    }

    // add函数的重载 ,获取三个值的和
    public static int add(int x,int y,int z){
        int sum = x+y+z;
        return sum;
    }
}
```

#### 方法的重写

重载和重写的区别

> https://blog.csdn.net/LosingCarryJie/article/details/87736026

#### 方法的递归

函数的内部调用自身的过程

```
// 斐波那契数列
public class RecursionFibonacci {
public static void main(String[] args) {
	// 1 1 2 3 5 8 13 21 34 55 89
	Scanner sc = new Scanner(System.in);
	System.out.println("请输入fibonacci的项数：");
	int inpu = sc.nextInt();	
	int result = fibonacci(inpu);
	System.out.println(result);
}
public static int  fibonacci(int n){
	if (n == 0){
		return 0;
	}else if(n==1) {
		return 1;
	}
	return fibonacci(n-1)+fibonacci(n-2);
	}
}
```

递归输出文件目录名

```
public class RecursionFileName {   
public static void main(String[] args) {
        String path = "D:/";                   // 设定文件路径
        test(path);
    }
    private static void test(String path) {			// 输出文件目录函数
        File f = new File(path);				// 创建一个文件路径对象
        File[] fs = f.listFiles();				// 创建文件路径列表的数组
        if (fs == null) {						// if数组为空，则返回
            return;
        }
        for (File file : fs) {					// 输出数组
            if (file.isFile()) {
                System.out.println(file.getPath());
            } else {
                test(file.getPath());
            }
        }
    }
}
```

### 构造方法

> https://bbs.huaweicloud.com/blogs/308778
>
> 
>
> https://bbs.huaweicloud.com/blogs/311916
>
> 
>
> https://blog.csdn.net/qq_47897078/article/details/120243801





### 初始化

#### 类初始化

#### 成员初始化

#### 构造方法初始化

#### 初始化顺序

#### 数组初始化

### 封装

- 为了不直接被外部使用，提高代码的安全性
- 就是降低类的使用者的学习成本，不需要知道类的实现，只需要学会调用就好了

### 继承



### 多态

### 关键字

#### final

#### static

#### this

#### super

#### volatile

#### synchronized

#### transient

> https://zhuanlan.zhihu.com/p/284345618







### 内部类

#### 内部类有坑，100%内存泄露！

> https://mp.weixin.qq.com/s/ws13ccJF5BQyfjuk3VuXFg





## 泛型

> https://bbs.huaweicloud.com/blogs/326364

### 类型擦除

> https://bbs.huaweicloud.com/blogs/362220





## 注解

## 反射

## 文件

## 正则表达式

## 集合

### 遍历Map集合

> https://bbs.huaweicloud.com/blogs/300649

### 数组和List相互转换

> https://bbs.huaweicloud.com/blogs/300641



### ArrayList

> 源码分析1
>
> https://blog.csdn.net/qq_40399646/article/details/113806756
>
> 1、EMPTY_ELEMENTDATA 和 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的区别
>
> *  EMPTY_ELEMENTDATA 创建一个大小为0的 list （容量从0开始）
> *  DEFAULTCAPACITY_EMPTY_ELEMENTDATA 创建一个默认空参 list （容量从10开始）
>
> 2、ArrayList 为什么要将存储数据的数组用 transient 修饰？
>
> *  1、ArrayList 会扩容
> *  2、ArrayList 的元素可以进行删除
> *  3、ArrayList 容量并不会缩容
> *  减少Null值的序列化到硬盘，优化存储空间
>
> 比如：一个 ArrayList 里有1000个值，存储1000个值，但删除999个之后，剩下一个值
>
> 此时，如果使用jdk自带序列化，需要序列化1000个值（999个null）
>
> ArrayList 自己实现了序列化方法 writeObject() 只需要序列化1个值



### LinkedList

> https://blog.csdn.net/K_520_W/article/details/122550485



### HashMap



### LinkedHashMap



### TreeMap











## 常用类

### Object

> https://blog.csdn.net/hyh17808770899/article/details/110956045

### Integer

> https://blog.csdn.net/Herishwater/article/details/101317700
>
> https://blog.csdn.net/Huang1178387848/article/details/111480137

### String

> https://bbs.huaweicloud.com/blogs/279319
>
> https://blog.csdn.net/qq_34287953/article/details/82021991

#### String.intern()

> https://blog.csdn.net/tianyuzui6/article/details/124417267



### 日期时间

> https://bbs.huaweicloud.com/blogs/280476

### Arrays

> https://blog.csdn.net/en_joker/article/details/102651217



### StringBuffer和StringBuilder

>https://bbs.huaweicloud.com/blogs/280641

### Decimal



### DecimalFormat

> https://blog.csdn.net/lly1122334/article/details/89761931

### LongAdder

>  https://blog.51cto.com/u_14518853/4893881



### 其他

> https://bbs.huaweicloud.com/blogs/280961



## 网络

### 拔掉网线后， 原本的 TCP 连接还存在吗？

> https://mp.weixin.qq.com/s/rmLezj4_EcCMB-MaQ361oQ

### 网关系统

> https://mp.weixin.qq.com/s/bBdjGt4eZ3sZTG_y56eCIQ

## 多线程

### ThreadLocal详解

> https://mp.weixin.qq.com/s/klhLeoVgPKzRoTVSBmjFFA





### Java多线程四种常用创建方式

> https://bbs.huaweicloud.com/blogs/279132

### 什么是线程安全的

当多个线程访问一个类时 ，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步以及在调用方式代码不必作其他的协调，这个类的行为仍然是正确的，那么称为线程安全的。

一个对象的**状态** 就是它的**数据** ，存储在状态变量中，比如实例域或者静态域，对象的状态还包括了其他附属对象的域。

**所谓共享，就是指的是一个变量可以被多个线程访问；所谓可变就是指变量的值在器生命周期内可以改变。我们讨论的线程安全性好像是关于代码的，但是我们真正要做的事情是在不可控制的并发访问中保护数据。**

一个对象是否应该是线性安全的取决于它是否被多个线程访问。线程安全的这个性质，取决于程序中如何使用对象，而不是对象完成了什么。保证对象的形成安全性需要使用同步来协调对其他可变状态的访问。如果做不到这一点，就会导致肮脏数据的参数的产生和其他不可预见的结果。

在没有同步的情况下，如果多个线程访问了同一个变量，你的程序就存在隐患了。有三个方法来修复它：

**不要跨线程共享数据**

**使用状态变量变为不可不的那种。**

**在任何访问状态下变量的时候使用同步**

 

### 线程池

#### 优点

- 重复利用线程
  - 可以复用线程，降低了创建和销毁的性能开销
  - 提升任务的响应速度，当有新任务需要执行时不需创建线程可以立即执行
- 控制线程的数量
  - 可以根据系统承受能力，通过合理的控制线程数，防止线程数过多导致服务崩溃。
  - 线程池可以对线程进行统一的管理，支持更多的功能。

#### 实现原理

- 1）线程池管理器：用于创建并控制线程数量，包括创建线程和销毁线程；
- 2）工作线程：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
- 3）任务队列：用于缓存提交的任务。
- 4）任务拒绝策略：如果任务队列已满且线程数已达到上限，则需要有相应的拒绝策略来处理后续任务。

#### 线程池的5种状态

- 1）RUNNING：运行状态。接受新任务并且处理阻塞队列里的任务。
- 2）SHUTDOWN：拒绝新任务但是处理阻塞队列里的任务。
- 3）STOP：拒绝新任务并且抛弃阻塞队列里的任务，同时会中断正在处理的任务。
- 4）TIDYING：所有任务都执行完（包含阻塞队列里面的任务）后当前线程池活动线程数为0，将调用terminated方法。
- 5）TERMINATED：终止状态。terminated方法调用完成以后的状态。

#### ThreadPoolExecutor

##### 工作流程

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221230_161022.jpg)

##### execute()

提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。

##### submit()

用于提交需要返回值的任务。

##### shutdown()

关闭线程池，这时线程池不再接收新的任务，线程池中的所有任务（包括正在执行的和等待队列中的）完成后，线程池关闭

##### shutdownNow()

立即关闭线程池，这时线程池不再接收新的任务，线等待队列中的线程将不会被执行，并尝试中断正在运行的线程。









## Java 8

### 方法引用与构造器引用

> https://bbs.huaweicloud.com/blogs/308272

### 函数式接口

> https://bbs.huaweicloud.com/blogs/308271

### Lambda表达式

> https://bbs.huaweicloud.com/blogs/308270



# 框架

## java框架

### Spring Security

#### Spring Security 最佳实践

> https://mp.weixin.qq.com/s/3_x3FaphCjUVL0KHza9ivg
>
> https://www.pudn.com/news/6318191d88df2007aa388a72.html



### SpringBoot

#### Spring Validation的使用

> https://jishuin.proginn.com/p/763bfbd6f5d5

#### SpringBoot封装响应数据和异常处理

> https://mp.weixin.qq.com/s/-XrKZkrYV1ejvNN4GxCfXA

#### SpringBoot 时间格式化的 5 种实现方法！

> https://blog.csdn.net/weixin_44016938/article/details/126382747

#### SpringBoot 项目优雅实现 Excel 导入导出功能

> https://mp.weixin.qq.com/s/gAIFceDOFqiyVu0ckZyfjQ

#### SpringBoot 设置动态定时任务

> https://mp.weixin.qq.com/s/Kc64nDZ4c8yuF5HtdssrcQ

### SpringCloud

#### SpringCloud问题

> https://mp.weixin.qq.com/s/xHJCQt97RNdGrf0VnTT_kA

# 中间件

## mybatis

## MyBatis-Plus

### MyBatis-Plus常用API全套教程，看完没有不懂的

> https://mp.weixin.qq.com/s/X7yolbcYUPiHXJ-n-xjvwQ

### 利用线程特性与ThreadLocal来解决公共字段自动填充问题

> https://mp.weixin.qq.com/s/SKepcX66oNQqmXr2BG8Kpw

## 数据库

### MySQL

#### MySql基础

> https://bbs.huaweicloud.com/blogs/293305

#### MySQL replace()字符串替换函数的使用

> https://www.cnblogs.com/kegui/p/16642909.html

#### mysql 最大建议行数 2000w, 靠谱吗？

> https://mp.weixin.qq.com/s/dTvVbtt3F9GQyCvjx2bHGw







### SQL优化

#### 1、explain

##### Extra

- using index：SQL所需要的返回值所有列数据均在一颗索引树上，即无需访问实际的行记录
- using where：SQL使用了where过滤条件

注：使用了where条件的SQL，并不代表不需要优化，需要进一步判断explain执行计划中type的类型，如果type为all，表示进行了全表扫描，则需要优化，否则不需要优化

- using index condition：说明检索确实命中索引，但不是所有的列都在索引树上，还有需要访问实际的行记录，这个SQL语句性能也很高，但不如using index
- using filesort：得到的所有的结果集，需要进行文件排序，SQL语句性能很差，需要优化

##### select_type

- SIMPLE(简单查询。查询不包含子查询和union)
- PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)
-  UNION(UNION中的第二个或后面的SELECT语句)
-  DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)
-  UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)
- SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)
- DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)
- DERIVED(派生表的SELECT, FROM子句的子查询)
-  UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)

##### Table

这一列表示 explain 的一行正在访问哪个表

##### possible_keys 和 key

possible_keys这一列显示查询可能使用哪些索引来查找，key是真正使用的索引。
explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。

##### type

- system：表仅有一行，基本用不到；
- const：表最多一行数据配合，主键查询时触发较多；
- eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型；
- ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取；
- range：只检索给定范围的行，使用一个索引来选择行。当使用=、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range；

- index：该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小；

- all：全表扫描；

- 性能排名：system > const > eq_ref > ref > range > index > all。

- 实际sql优化中，最后达到ref或range级别。

#### 2、避免在where子句中使用 or 来连接条件

反例

```
SELECT * FROM user WHERE id=1 OR salary=5000
```

正例

使用union all或者分两条SQL写

```
SELECT * FROM user WHERE id=1 
UNION ALL
SELECT * FROM user WHERE salary=5000

SELECT * FROM user WHERE id=1
SELECT * FROM user WHERE salary=5000
```

使用`or`可能会使索引失效，从而全表扫描；

对于`or`没有索引的`salary`这种情况，假设它走了`id`的索引，但是走到`salary`查询条件时，它还得全表扫描；

也就是说整个过程需要三步：全表扫描+索引扫描+合并。如果它一开始就走全表扫描，直接一遍扫描就搞定；

虽然`mysql`是有优化器的，出于效率与成本考虑，遇到`or`条件，索引还是可能失效的；

#### 3、使用数值替代字符串类型

- 因为引擎在处理查询和连接时会逐个比较字符串中每一个字符；

- 而对于数字型而言只需要比较一次就够了；

- 字符会降低查询和连接的性能，并会增加存储开销；

#### 4、使用varchar代替char

- varchar`变长字段按数据内容实际长度存储，存储空间小，可以节省存储空间；

- char`按声明大小存储，不足补空格；

- 其次对于查询来说，在一个相对较小的字段内搜索，效率更高；

#### 5、避免在where子句中使用!=或<>操作符

- 使用`!=`和`<>`很可能会让索引失效

- 应尽量避免在`where`子句中使用`!=`或`<>`操作符，否则引擎将放弃使用索引而进行全表扫描

- 实现业务优先，实在没办法，就只能使用，并不是不能使用

#### 6、提高group by语句的效率

先过滤，后分组，可以在执行到该语句前，把不需要的记录过滤掉

```
SELECT
	job， avg（ salary） 
FROM
	employee 
WHERE
	job = 'develop'
GROUP BY job;
```

#### 7、优化like语句

```
select * from citys where name like '大连%' (使用索引) 。
```

- 首先尽量避免模糊查询，如果必须使用，不采用全模糊查询，也应尽量采用右模糊查询， 即`like ‘…%’`，是会使用索引的；
- 左模糊`like ‘%...’`无法直接使用索引，但可以利用`reverse + function index`的形式，变化成 `like ‘…%’`；
- 全模糊查询是无法优化的，一定要使用的话建议使用搜索引擎。

#### 8、查询SQL尽量不要使用select \*，而是具体字段

```
SELECT
	id, username,phone 
FROM
	tb_sys_org
```





### 分库分表

#### SpringBoot做MySQL分库分表

> https://www.pudn.com/news/631e930ef0cde61357459786.html
>
> https://mp.weixin.qq.com/s/-HWpqaee33sk7SU4DgGzHQ

#### SpringBoot + Sharding JDBC，一文搞定分库分表、读写分离

https://mp.weixin.qq.com/s/jUnyL8vLk-owFSu1TzMA2A





































# 数据结构和算法

## 数组和链表

> https://www.cnblogs.com/54chensongxia/p/11474539.html

## 栈

> https://blog.csdn.net/weixin_53227758/article/details/123000527



## 排序算法

> https://www.cnblogs.com/xiaozhongfeixiang/p/11751494.html
>
> https://www.sohu.com/na/421549356_99979179

### 分类

- 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。

- 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221122_110233.jpg)

### 复杂度 

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221122_110443.jpg)

- 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。

### 冒泡排序

两两比较相邻的关键码，如果反序则交换，直到没有反序的记录为止

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221121_145656.jpg)

```
/**
 * @Description 冒泡排序
 * @Author huangxiao
 * @Date 2022-11-16
 */
public class BubbleSort {
    public static void main(String[] args) {
        int[] sortArray = {10, 23, 11, 56, 45, 26, 59, 28, 84, 79, 1, 5, 3, 89, 45, 26, 23, 11};
        outputArray(sortArray);

        for (int i = 0; i < sortArray.length - 1; i++) {
            for (int j = 0; j < sortArray.length - i - 1; j++) {
                if (JudgeSize(sortArray[j], sortArray[j + 1])) {
                    changePosition(j, sortArray);
                }
            }
            outputArray(sortArray, i + 1);
        }

        outputArray(sortArray);
    }

    /**
     * 数组输出
     */
    public static void outputArray(int[] inputArray) {
        System.out.println("数组遍历输出：");
        for (int value : inputArray) {
            System.out.print(value + "  ");
        }
        System.out.println();
    }

    /**
     * 数组输出
     */
    public static void outputArray(int[] inputArray, int num) {
        System.out.println("第" + num + "次输出数组：");
        for (int value : inputArray) {
            System.out.print(value + "  ");
        }
        System.out.println();
    }

    /**
     * 判断大小
     */
    public static boolean JudgeSize(int num1, int num2) {
        return num1 > num2;
    }

    /**
     * 交换位置
     */
    public static int[] changePosition(int num, int[] sortArray) {
        int temp = sortArray[num];
        sortArray[num] = sortArray[num + 1];
        sortArray[num + 1] = temp;
        return sortArray;
    }
}
```

### 快速排序

> https://blog.csdn.net/zhuxian1277/article/details/112466047

首先选定一个轴值（就是比较的基准），将待排序记录分割成独立的两部分，左侧记录的关键码都小于或是等于轴值，右侧的记录关键码都大于或等于轴值，然后在对这两部分分别重复上述的过程，直到整个序列有序。

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221121_161738.jpg)

```
/**
 * @Description 快速排序
 * @Author huangxiao
 * @Date 2022-11-21
 */
public class QuickSort {
    public static void main(String[] args) {
        int[] array = {6, 4, 7, 56, 23, -101, -77, -1, 0, 5, 0, 100};
        outputArray(array);
        quickSort(array, 0, array.length - 1);
        outputArray(array);
    }

    public static void quickSort(int[] array, int left, int right) {
        if (left >= right) {
            return;
        }
        // 先求出基准数的下标
        int index = sort(array, left, right);
        if (index != 0) {
            // 对基准数左边递归
            quickSort(array, left, index - 1);
            // 对基准数右边递归
            quickSort(array, index + 1, right);
        }
    }

    /**
     * left，左边界.
     * right,右边界.范围array.length-1
     */
    public static int sort(int[] array, int start, int end) {
        // 找出一个基准数,使得左边的数<=基准数,基准数>=右边的数,返回此基准数下标
        // 假设第一个数就是基准数
        int s = start;
        while (start < end) {
            // 从右边开始找到小于等于基准数的
            while (start < end && array[end] > array[s]) {
                end--;
            }
            // 从左边开始找到大于基准数的
            while (start < end && array[s] >= array[start]) {
                start++;
            }
            // end>start 说明小于等于基准数还在右边,大于基准数的在左边,两两交换即可
            if (end > start) {
                swap(array, start, end);
            }
        }
        swap(array, s, start);
        return start;
    }

    /**
     * 交换位置
     */
    public static void swap(int[] sortArray, int start, int end) {
        int temp = sortArray[start];
        sortArray[start] = sortArray[end];
        sortArray[end] = temp;
    }

    /**
     * 数组输出
     */
    public static void outputArray(int[] inputArray) {
        System.out.println("数组遍历输出：");
        for (int value : inputArray) {
            System.out.print(value + "  ");
        }
        System.out.println();
    }
}
```

> 解决Exception in thread “main” java.lang.StackOverflowError
>
> https://blog.csdn.net/weixin_44917577/article/details/117200555

### 选择排序

每趟排序在当前待排序序列中选出关键码最小的记录，添加到有序序列中。

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221121_165518.jpg)

```
/**
 * @Description 选择排序
 * @Author huangxiao
 * @Date 2022-11-21
 */
public class SelectSort {
    public static void main(String[] args) {
        int[] array = {6, 4, 7, 56, 23, -101, -77, -1, 0, 5, 0, 100};
        outputArray(array);
        selectSort(array, 0);
        outputArray(array);
    }

    public static void selectSort(int[] array, int index) {
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = i + 1; j < array.length - 1; j++) {
                if (array[j] < array[index]) {
                    index = j;
                }
            }
            if (index != i) {
                swap(array, i, index);
            }
        }
    }

    /**
     * 交换位置
     */
    public static void swap(int[] sortArray, int start, int end) {
        int temp = sortArray[start];
        sortArray[start] = sortArray[end];
        sortArray[end] = temp;
    }

    /**
     * 数组输出
     */
    public static void outputArray(int[] inputArray) {
        System.out.println("数组遍历输出：");
        for (int value : inputArray) {
            System.out.print(value + "  ");
        }
        System.out.println();
    }
}
```

### 堆排序

> https://blog.csdn.net/fengyuyeguirenenen/article/details/125112681

```
/**
 * @Description 堆排序
 * @Author huangxiao
 * @Date 2022-11-21
 */
public class HeapSort {
    public static void main(String[] args) {
        int[] array = {4, 6, 8, 78, 13, 19, 1, 5, 9,};
        outputArray(array);
        heapSort(array);
        outputArray(array);
    }

    public static void heapSort(int[] array) {
        // 从倒数第一个非叶子节点开始
        for (int i = array.length / 2 - 1; i >= 0; i--) {
            // 从第一天非叶子节点从下至上，从左至右调整结构
            adjustHeap(array, i, array.length);
        }
        // 将堆顶元素与末尾元素交换 将最大元素沉到数组末尾 + 重新调整堆结构
        for (int i = array.length - 1; i > 0; i--) {
            // 交换堆顶元素和末尾元素
            swap(array, 0, i);
            // 交换后的末尾元素忽略(j--) 不再参与堆结构的调整
            // 重新调整堆结构
            adjustHeap(array, 0, i);
        }
    }

    public static void adjustHeap(int[] array, int index, int length) {
        // 取出当前元素
        int temp = array[index];
        // i节点是index节点的左子节点
        for (int i = 2 * index + 1; i < length; i = 2 * i + 1) {
            // 表明左子节点小于右子节点
            if (i + 1 < length && array[i] < array[i + 1]) {
                // 将指针移至较大节点
                i++;
            }
            // 如果子节点大于父节点
            if (array[i] > temp) {
                // 将较大值赋给当前节点
                array[index] = array[i];
                // 指针移向子节点
                index = i;
            } else {
                break;
            }
        }
        // 循环结束，已经将最大值放在了堆顶
        // 将temp值放到最终的位置
        array[index] = temp;
    }

    /**
     * 交换位置
     */
    public static void swap(int[] sortArray, int start, int end) {
        int temp = sortArray[start];
        sortArray[start] = sortArray[end];
        sortArray[end] = temp;
    }

    /**
     * 数组输出
     */
    public static void outputArray(int[] inputArray) {
        System.out.println("数组遍历输出：");
        for (int value : inputArray) {
            System.out.print(value + "  ");
        }
        System.out.println();
    }
}
```

### 插入排序

> https://blog.csdn.net/m0_66435981/article/details/124282325

每次将一个待排序的记录按其关键码的大小插入到一个已经排好序的有序序列中，直到全部记录排好序。

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221121_173902.jpg)

```
/**
 * @Description 插入排序
 * @Author huangxiao
 * @Date 2022-11-21
 */
public class InsertSort {
    public static void main(String[] args) {
        int[] array = {6, 4, 7, 56, 23, -101, -77, -1, 0, 5, 0, 100};
        outputArray(array);
        insertSort(array);
        outputArray(array);
    }

    public static void insertSort(int[] array) {
        for (int i = 0; i < array.length; i++) {
            int temp = array[i];
            int j = i - 1;
            for (; j >= 0; j--) {
                if (array[j] > temp) {
                    array[j + 1] = array[j];
                } else {
                    // array[j+1]=tmp;
                    break;
                }
            }
            array[j + 1] = temp;
        }
    }

    /**
     * 数组输出
     */
    public static void outputArray(int[] inputArray) {
        System.out.println("数组遍历输出：");
        for (int value : inputArray) {
            System.out.print(value + "  ");
        }
        System.out.println();
    }
}
```

### 归并排序

> https://blog.csdn.net/weixin_50941083/article/details/120852477

### 希尔排序

### 计数排序

### 桶排序

### 基数排序











## 查找

### 二分查找

- 查询速度是非常快的，比较次数少，平均性能好。
- 缺点就是二分查找必须有个前提就是数组是有序的，而且插入删除都比较困难。

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/20210327152307712.gif)



```
    /**
     * Arrays类的binarySearch方法
     * 如果需要查找的数据存在，就返回数组中对应数据的下标值，
     * 如果不存在，返回值为：-（应该插入的位置索引+1）
     *
     * @param array     有序数组
     * @param searchNum 查找的数
     * @return 查找的数的下标
     */
    public static int binarySearch(int[] array, int searchNum) {
        return Arrays.binarySearch(array, searchNum);
    }

    /**
     * 迭代方式
     *
     * @param array     有序数组
     * @param searchNum 查找的数
     * @return 查找的数的下标
     */
    public static int binarySearchIteration(int[] array, int searchNum) {
        //初始化最小值的索引为0
        int left = 0;
        //初始化最大值的索引为arr.length-1
        int right = array.length - 1;
        //首尾相加再除以2得出中间索引
        int mid = (left + right) / 2;
        while (left <= right) { //确保程序不会重复查询，不会越界
            if (searchNum > array[mid]) {
                //如果查询的值比中间值大，则往右边区域找，就把最小索引改为中间索引右移一位
                left = mid + 1;
            } else if (searchNum < array[mid]) {
                //如果查询的值比中间值小，则往左边区域找，就把最大索引改为中间索引左移一位
                right = mid - 1;
            } else {
                //剩余的情况就是查询到了结果，那么就直接返回索引。
                return mid;
            }
            mid = (left + right) / 2;
        }
        //没有查询到，则返回-1
        return -1;
    }

    /**
     * 递归方式
     *
     * @param array     有序数组
     * @param searchNum 查找的数
     * @return 查找的数的下标
     */
    public static int binarySearchRecursion(int[] array, int searchNum) {
        //初始化最小值的索引为0
        int left = 0;
        //初始化最大值的索引为arr.length-1
        int right = array.length - 1;
        if (left > right) {
            return -1;
        }
        int mid = (left + right) / 2;
        if (array[mid] == searchNum) {
            return mid;
        } else if (array[mid] > searchNum) {
            return binarySearchRecursion(array, mid - 1);
        } else {
            return binarySearchRecursion(array, searchNum);
        }
    }
```





# 设计和结构

## 设计模式

## 架构

### 8种架构

> https://mp.weixin.qq.com/s/per0sigoPNTMYRr4oN1AVw

# 运维

# 分布式

# 工具

## GitHub

### 本地项目上传到github

#### 创建仓库

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20220829_112143.png)

#### 配置SSH Key

如果没有配置github，需要配置

#### 本地项目初始化

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20220829_112628.png)

#### 在终端下关联git仓库

运行：**git remote add origin git@github.com:【你的github用户名】/【仓库名称】.git**，例如`git remote add origin git@github.com:itmacy/cloud-note.git`

```
xiao@xiao MINGW64 /f/读书破万卷/xiao (master)
$  git remote add origin git@github.com:xiao2769433/xiao.git
```

#### 代码提交

- 把本地所有文件添加到缓冲区，运行：`git add .`
- 提交所有文件，运行：`git commit -m ‘添加项目’`
- 推送到git仓库，运行：`git push —set-upstream origin master`

## IDEA

### IDEA官网

> https://www.jetbrains.com/idea/

### IDEA断点调试技巧

> https://blog.51cto.com/u_15454291/5341117





## Lombok

### Lombok 同时使⽤ @Data 和 @Builder 的坑

Lombok原理

https://blog.csdn.net/afreon/article/details/125631273



# 程序员的自我修养

## 优化

### 性能优化的 10 个技巧！

> https://mp.weixin.qq.com/s/SgSU53cY4LcLKZ3bKKluSg

### 消除if...else

> https://cloud.tencent.com/developer/article/1769479





### String.format()拼接字符串

请求地址拼接

```
String url = "http://127.0.0.1?userName="+userName+"&age="+age+"&address="+address+"&sex="+sex+"&roledId="+roleId;
```

使用`StringBuilder`拼接字符串

```
StringBuilder urlBuilder = new StringBuilder("http://127.0.0.1?");
urlBuilder.append("userName=")
.append(userName)
.append("&age=")
.append(age)
.append("&address=")
.append(address)
.append("&sex=")
.append(sex)
.append("&roledId=")
.append(roledId);
```

使用`String.format`方法优化

```
String requestUrl = "http://127.0.0.1?userName=%s&age=%s&address=%s&sex=%s&roledId=%s";
String url = String.format(requestUrl,userName,age,address,sex,roledId);
```

### 减少循环次数

在我们日常开发中，循环遍历集合是必不可少的操作。

但如果循环层级比较深，循环中套循环，可能会影响代码的执行效率。

`反例`：

```
for(User user: userList) {
   for(Role role: roleList) {
      if(user.getRoleId().equals(role.getId())) {
         user.setRoleName(role.getName());
      }
   }
}
```

这个例子中有两层循环，如果userList和roleList数据比较多的话，需要循环遍历很多次，才能获取我们所需要的数据，非常消耗cpu资源。

`正例`：

```
Map<Long, List<Role>> roleMap = roleList.stream().collect(Collectors.groupingBy(Role::getId));
for (User user : userList) {
    List<Role> roles = roleMap.get(user.getRoleId());
    if(CollectionUtils.isNotEmpty(roles)) {
        user.setRoleName(roles.get(0).getName());
    }
}
```

减少循环次数，最简单的办法是，把第二层循环的集合变成`map`，这样可以直接通过`key`，获取想要的`value`数据。

虽说map的key存在`hash冲突`的情况，但遍历存放数据的`链表`或者`红黑树`的`时间复杂度`，比遍历整个list集合要小很多。

### 初始化集合时指定大小

在实际项目开发中，需要经常使用集合，比如：ArrayList、HashMap等。

`反例`：

```
public class Test2 {

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        long time1 = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            list.add(i);
        }
        System.out.println(System.currentTimeMillis() - time1);
    }
}
```

执行时间：

```text
12
```

如果在初始化集合时指定了大小。

`正例`：

```text
public class Test2 {

    public static void main(String[] args) {
        List<Integer> list2 = new ArrayList<>(100000);
        long time2 = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            list2.add(i);
        }
        System.out.println(System.currentTimeMillis() - time2);
    }
}
```

执行时间：

```text
6
```

在创建集合时指定了大小，比没有指定大小，添加10万个元素的效率提升了一倍。

`ArrayList`源码，它的默认大小是`10`，如果添加元素超过了一定的阀值，会按`1.5`倍的大小扩容。

如果装10万条数据，需要扩容很多次，而每次扩容都需要不停的复制元素，从老集合复制到新集合中，需要浪费多少时间。

### 状态用枚举

在建的表中，有很多状态字段，比如：订单状态、禁用状态、删除状态等。

每种状态都有多个值，代表不同的含义。

比如订单状态有：

- 1：表示下单
- 2：表示支付
- 3：表示完成
- 4：表示撤销

如果没有使用枚举，一般是这样做的：

```text
public static final int ORDER_STATUS_CREATE = 1;
public static final int ORDER_STATUS_PAY = 2;
public static final int ORDER_STATUS_DONE = 3;
public static final int ORDER_STATUS_CANCEL = 4;
public static final String ORDER_STATUS_CREATE_MESSAGE = "下单";
public static final String ORDER_STATUS_PAY = "下单";
public static final String ORDER_STATUS_DONE = "下单";
public static final String ORDER_STATUS_CANCEL = "下单";
```

需要定义很多静态常量，包含不同的状态和状态的描述。

使用`枚举`定义之后，代码如下：

```text
public enum OrderStatusEnum {  
     CREATE(1, "下单"),  
     PAY(2, "支付"),  
     DONE(3, "完成"),  
     CANCEL(4, "撤销");  

     private int code;  
     private String message;  

     OrderStatusEnum(int code, String message) {  
         this.code = code;  
         this.message = message;  
     }  
   
     public int getCode() {  
        return this.code;  
     }  

     public String getMessage() {  
        return this.message;  
     }  
  
     public static OrderStatusEnum getOrderStatusEnum(int code) {  
        return Arrays.stream(OrderStatusEnum.values()).filter(x -> x.code == code).findFirst().orElse(null);  
     }  
}
```

使用枚举改造之后，职责更单一了。

而且使用枚举的好处是：

1. 代码的可读性变强了，不同的状态，有不同的枚举进行统一管理和维护。
2. 枚举是天然单例的，可以直接使用==号进行比较。
3. code和message可以成对出现，比较容易相关转换。
4. 枚举可以消除if...else过多问题。





## 陷阱与细节

### for删除集合元素陷阱

> https://blog.csdn.net/Charles_7c/article/details/125660022

```
public class ForCycleCollection {

    public static void main(String[] args) {
        String temp = "xiao";
        ArrayList<String> forList = Lists.newArrayList("xiao", "xiao", "bu", "de", "mei", "shan");
        System.out.println(forList); // [xiao, xiao, bu, de, mei, shan]
        for (int i = 0; i < forList.size(); i++) {
            if (temp.equals(forList.get(i))) {
                forList.remove(i);
            }
        }
        System.out.println(forList);  // [xiao, bu, de, mei, shan]

        ArrayList<Integer> list = Lists.newArrayList(1, 2, 2, 3, 4);
        System.out.println(list);      // [1, 2, 2, 3, 4]
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i) % 2 == 0) {
                list.remove(i);
                i--;
            }
        }
        System.out.println(list);   // [1, 3]

        ArrayList<Integer> list1 = Lists.newArrayList(1, 2, 2, 3, 4);
        System.out.println(list1);      // [1, 2, 2, 3, 4]
        for (int i = 0; i < list1.size(); i++) {
            if (list1.get(i) % 2 == 0) {
                i--;
                list1.remove(i);
            }
        }
        System.out.println(list1);   // [2, 4]
    }
}
```

### 浮点数差值损失

```
public static void main(String[] args) {
    /**
    * 精度丢失问题
    */
    double result = 3.00 - 2.61;
    System.out.println(result);   // 0.3900000000000001

    /**
    * BigDecimal 解决了浮点数相减错误的问题，但可能会造成程序运行速度的下降，因为该类并没有很好地得到Java语言的支持。
    */
    BigDecimal num1 = new BigDecimal("3.33");
    BigDecimal num2 = new BigDecimal("1.63");
    BigDecimal num3 = num1.subtract(num2);
    System.out.println(num3);   // 1.70
    double num3Double = num3.doubleValue();
    System.out.println(num3Double); // 1.7

    /**
    * 将 浮点数 转换为整数 提升效率
    */
    double num21 = 3.33D;
    double num22 = 1.39D;
    long num23 = (long) (num21 * 100);
    long num24 = (long) (num22 * 100);
    long resultNum = num23 - num24;
    double resultNum1 = resultNum/100.0;
    System.out.println(resultNum1);
}
```

### Java 中 |与||，&与&&的区别

> https://blog.csdn.net/zjt980452483/article/details/82688648

|| 与 && 都是短路功能：

(表达式一) || (表达式二)，则当表达式一为真，表达式二不执行。

(表达式一) && (表达式二)，则当表达式一位假，表达式二不执行。

对于&：无论&左边是否为false，他都会继续检验右边的boolean值。

对于&&:只要检测到左边Boolean值为false时，就会直接判断结果，不会在检验右边的值（因为"与"有一个false最后结果就是false了）

所以&&的执行效率更高，所以一般都是使用&&。

|与||之间也是同样的道理，|：无论左边是否为ture，都会检验右边 ，||：则不会。||  的执行效率会更高

### 默认构造方法并不都是public

- 默认构造方法的修饰符是与所在类的修饰符一致的，也就是说如果类是public的，默认构造方法的修饰符就是public的

- 如果类无修饰符，默认构造方法也将没有修饰符。

```
public class Test {
    public Test() {
    	super();
    }
}

class Test {
    Test() {
        super();
    }
}
```

### 实体类不要使用基本类型

（一）定义实体类时，如果属性的类型定义成int类型，在前台jsp页面数据呈现时，会默认显示为0.而Integer不会显示0.Integer是包装类，包装类符合对象的特征并提供了一些必要的属性和方法。

（二）如果返回字段值为null，int类型会报错，Integer不会报错。因为int类型声明的是变量，而null是对象所以会报错。

（三）int类型的默认值为0，Integer类型的默认值为null。

结论:在mybatis中，不要使用基本类型，要使用引用类型。









### 细数List的10个坑

> https://blog.csdn.net/m0_73311735/article/details/126890501







## 其他

### javap命令对代码进行反汇编

> https://blog.csdn.net/LosingCarryJie/article/details/88387962

查看电脑是否安装jdk以及安装了的路径

> https://www.cnblogs.com/damugua/p/16347387.html

‘javap‘ 不是内部或外部命令，也不是可运行的程序 或批处理文件。

> https://blog.csdn.net/weixin_45639532/article/details/115861764

### IDEA 查看代码反汇编代码

> https://blog.csdn.net/gaowenhui2008/article/details/116262133





## 博客

### 1、程序员的酒后真言

> https://mp.weixin.qq.com/s/oJidlcwXMv37IJA2J_0tbA
>
> https://zhuanlan.zhihu.com/p/421168832

### 2、阿里禁用 boolean 类型变量用 isXxx 命名，why？

> https://mp.weixin.qq.com/s/OM3_q2xKq7o0JSXCk9sUvw





```
There are only two hard things in Computer Science: cache invalidation and naming things.

计算机科学中只有两件困难的事情：缓存失效和命名规范。

No code is the best way to write secure and reliable applications. Write nothing; deploy nowhere

不写代码，是编写安全可靠的应用程序的最佳方式。什么都不写；哪里都不部署。
```



# 读书笔记

## Base

### 《java语言程序设计-基础篇》

走马观花

### 《Java8实战》



## Database