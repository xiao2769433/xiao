# java基础

## 基础

###  版本

- Java SE（标准版）
- Java EE（企业版）
- Java ME（微缩版）

###  语言特点

- 面向对象(使用计算机模拟现实世界,解决现实题,贴近人类思维模式)
- 筒单(相对C、C+、C#,不易造成内存溢出、滅少代码量、代码可读性强)
- 跨平台(操作系统、服务器、数据库)
- 可靠性
- 安全性
- 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；
- 编译与解释并存

###  运行机制

.java源程序——编译器——.class字节码——解析器——机械码——计算机

### 环境搭建

- JDK（java development kit）
  开发环境，包含JRE+类库+开发工具包（编译器+调试工具）
- JRE（java runtime environment）
  运行环境，包含：JVM和解释器
- JVM（java virtual machine）
  不同的操作系统中，模拟相同的环境

## 语法

#### 语言基础

#####  变量

- 第一种声明方式——先声明后赋值
  数据类型   变量名;
  `Int age;//开辟整数変量空间`
  変量名=值
  `age=18;/将整数值赋给変量`
- 第二种声明方式——声明并赋值
  `int age = 18；`
- 第三种声明方式——多个同类型变量的声明并赋值
  `int x,y,z = 11,12,13;`
- 注意:Java是强类型语言,変量的类型必须与数据的类型一致。
- 声明一个变量后，必须用赋值语句对变量进行显式初始化

#####  常量

```
# 常量名一般使用大写字符
final 常量名=值;
final double PI=3.14; 
final String LOVE="imooc";
```

##### 运算符

###### 赋值运算符

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194703.png)

###### 算术运算符	

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194724.png)

###### 关系运算符

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194747.png)

###### 逻辑运算符	

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194804.png)

###### 位运算符

与（&）、非（~）、或（|）、异或（^）

###### 移位运算符

<<    :   左移运算符，num << 1,相当于num乘以2

\>>    :   右移运算符，num >> 1,相当于num除以2

\>>>   :   无符号右移，忽略符号位，空位都以0补齐

###### 三目运算符

格式
` 布尔表达式?结果1:结果2    //布尔表达式为真，则结果1，布尔表达式为假，则结果2` 

```
public static void main(String[] args) {
	int age = 18;
	String age1=age == 17?"成年了":"未成年";
	System.out.println(age1);
	int x = 10;
	int y = 5;
	int z;
	z = (x > y) ? x : y;//三目运算符
		/*if (x>y){
			z = x;
		}else {
			z = y;
		}*/
	System.out.println("z = " + z);
	}
}
```

###### 转义运算符

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211114_220021.png)

```
System.out.println("xx\tx\t");
System.out.println("y\nyy");
System.out.println("\\");
System.out.println("\"");
System.out.println("\'");
System.out.println("\rzzz");
```

##### 数据类型

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194820.png)

###### 数据类型转换

- 自动类型转换

byte->short->char->int->long->float->double

- 强制类型转换

```
public class TypeConversion {
    public static void main(String[] args) {
        short s = 123;
        int i = s;        	// 目标类型大于源类型  自动类型转换 short ---> int
        System.out.println(i);

        double d = i;       // 目标类型大于源类型  自动类型转换 int ---> double
        System.out.println(d);

        short num = 123;
        byte target = (byte) num;       // 目标类型小于源类型  强制类型转换 short ---> byte
        System.out.println(target);

        double x = 12.34;
        int y = (int) x;            // 目标类型小于源类型  强制类型转换 double ---> int
        System.out.println(y);

        short m = 258;
        byte n = (byte) m;      // 目标类型小于源类型  强制类型转换 short ---> byte
        System.out.println(n);

        int a = -65;
        char b = (char) a;      // 目标类型小于源类型  强制类型转换 int ---> char
        System.out.println(b);
    }
}
```

- 字符串转为Int类型

```
public class StringChangeToInt {
    public static void main(String[] args) {
        // 方式一
        int num = Integer.parseInt("56544");
        // 方式二
        int num2=Integer.valueOf("123");
        System.out.println(num+"  "+num2);
    }
}
```

###### 包装类

Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：

| 基本类型 | 对应的包装类（位于java.lang包中） |
| -------- | --------------------------------- |
| byte     | Byte                              |
| short    | Short                             |
| int      | **Integer**                       |
| long     | Long                              |
| float    | Float                             |
| double   | Double                            |
| char     | **Character**                     |
| boolean  | Boolean                           |

###### Integer类

- Integer类概述

  包装一个对象中的原始类型 int 的值

- Integer类构造方法及静态方法

| 方法名                                  | 说明                                   |
| --------------------------------------- | -------------------------------------- |
| public Integer(int   value)             | 根据 int 值创建 Integer 对象(过时)     |
| public Integer(String s)                | 根据 String 值创建 Integer 对象(过时)  |
| public static Integer valueOf(int i)    | 返回表示指定的 int 值的 Integer   实例 |
| public static Integer valueOf(String s) | 返回保存指定String值的 Integer 对象    |

- 示例代码

```java
public class IntegerDemo {
    public static void main(String[] args) {
        //public Integer(int value)：根据 int 值创建 Integer 对象(过时)
        Integer i1 = new Integer(100);
        System.out.println(i1);

        //public Integer(String s)：根据 String 值创建 Integer 对象(过时)
        Integer i2 = new Integer("100");
		//Integer i2 = new Integer("abc"); //NumberFormatException
        System.out.println(i2);
        System.out.println("--------");

        //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例
        Integer i3 = Integer.valueOf(100);
        System.out.println(i3);

        //public static Integer valueOf(String s)：返回保存指定String值的Integer对象 
        Integer i4 = Integer.valueOf("100");
        System.out.println(i4);
    }
}
```

###### 装箱与拆箱

> https://www.cnblogs.com/dolphin0520/p/3780005.html

基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：

* **装箱**：从基本类型转换为对应的包装类对象。

* **拆箱**：从包装类对象转换为对应的基本类型。

用Integer与 int为例：

基本数值---->包装对象

~~~java
Integer i = new Integer(4);//使用构造函数函数
Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法
~~~

包装对象---->基本数值

~~~java
int num = i.intValue();
~~~

> https://www.cnblogs.com/dolphin0520/p/3780005.html

Integer 例子:

```java
  Integer i1 = 40;
  Integer i2 = 40;
  Integer i3 = 0;
  Integer i4 = new Integer(40);
  Integer i5 = new Integer(40);
  Integer i6 = new Integer(0);
  
  System.out.println("i1=i2   " + (i1 == i2));
  System.out.println("i1=i2+i3   " + (i1 == i2 + i3));
  System.out.println("i1=i4   " + (i1 == i4));
  System.out.println("i4=i5   " + (i4 == i5));
  System.out.println("i4=i5+i6   " + (i4 == i5 + i6));   
  System.out.println("40=i5+i6   " + (40 == i5 + i6));     
```

结果：

```
i1=i2   true
i1=i2+i3   true
i1=i4   false
i4=i5   false
i4=i5+i6   true
40=i5+i6   true
```

解释：

语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。

###### 自动装箱与自动拆箱

由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：

```java
Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);
i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;
//加法运算完成后，再次装箱，把基本数值转成对象。
```

###### 基本类型转换为String

- 转换方式

  * 方式一：直接在数字后加一个空字符串

   - 方式二：通过String类静态方法valueOf()

- 示例代码

```java
public class IntegerDemo {
    public static void main(String[] args) {
        //int --- String
        int number = 100;
        //方式1
        String s1 = number + "";
        System.out.println(s1);
        //方式2
        //public static String valueOf(int i)
        String s2 = String.valueOf(number);
        System.out.println(s2);
        System.out.println("--------");
    }
}
```

  ###### String转换成对应的基本类型 

除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：

- `public static byte parseByte(String s)`：将字符串参数转换为对应的byte基本类型。
- `public static short parseShort(String s)`：将字符串参数转换为对应的short基本类型。
- `public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。
- `public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。
- `public static float parseFloat(String s)`：将字符串参数转换为对应的float基本类型。
- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。
- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的boolean基本类型。

代码使用（仅以Integer类的静态方法parseXxx为例）如：

- 转换方式
  - 方式一：先将字符串数字转成Integer，再调用valueOf()方法
  - 方式二：通过Integer静态方法parseInt()进行转换
- 示例代码

```java
public class IntegerDemo {
    public static void main(String[] args) {
        //String --- int
        String s = "100";
        //方式1：String --- Integer --- int
        Integer i = Integer.valueOf(s);
        //public int intValue()
        int x = i.intValue();
        System.out.println(x);
        //方式2
        //public static int parseInt(String s)
        int y = Integer.parseInt(s);
        System.out.println(y);
    }
}
```

> 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。

#### 流程控制

##### 选择分支

###### if...else...语句

###### switch语句

```
import java.util.Scanner;

public class WeekdaySwitch{
	public static void main(String[] args){	
		//一周计划
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入1-7的数字：");
		int weekDay = sc.nextInt();
		switch(weekDay){
			default:
				System.out.println("录入有误，请输入1~7之间的有效数字！");
				break;
			case 1:
				System.out.println("学习java");
				break;		
			case 2:
			case 5:
			case 6:
				System.out.println("玩游戏");
				break;		
			case 3:
				System.out.println("爬山");
				break;	
			case 4:
				System.out.println("上班");
				break;
			case 7:
				System.out.println("考试");
				break;			
		}	
		System.out.println("结束");		
	}
}
```

##### 循环

###### do...while循环

```
// do ... while循环
	public static void sum2() {
		int i = 0 ;
		int sum = 0;
		do{
			sum = sum + i;
			i++;
		}while(i<101);
		System.out.println(sum);
	}
```

###### while循环

```
// while循环
	public static void sum1() {
		int i = 0 ;
		int sum = 0;
		while(i<101){
			sum = sum + i;
			i++;
		}
		System.out.println(sum);
	}
```

###### for循环

```
// for循环
	public static void sum(){
		int sum = 0;
		for(int i=1;i<101;i++) {
			if(i%2!=0) {
			sum = sum + i;
			}
		}
		System.out.println(sum);
	}	
```

###### foreach 循环 (两个功能：1遍历数组 2 遍历集合）

```
public class ForEachCircular {
    public static void main(String[] args) {
        // foreach循环遍历数组
        String [] names = {"xiao","xian","hua","nian"};
        for(String name:names){
            System.out.print(name + "\t");
        }
        System.out.println();
        // foreach循环遍历集合
        ArrayList<String> ming = new ArrayList<String>();
        ming.add("xiao");
        ming.add("xian");
        ming.add("hua");
        ming.add("nian");
        for(String m:ming){
            System.out.print(m + "\t");
        }
    }
}
```

##### 跳转

###### break语句  :跳出循环

###### continue语句：跳出本次循环

```
public class BreakAndContinue {
    public static void main(String[] args) {
        for (int i = 1; i < 6 ; i++) {
            if (i % 5 ==0){
                break;
            }
            System.out.println("当前循环次数：" + i);
        }
        System.out.println("<--------------------->");
        for (int i = 1; i < 7 ; i++) {
            if (i % 5 ==0){
                continue;
            }
            System.out.println("当前循环次数：" + i);
        }
    }
}
```

####  java数组学习

> https://bbs.huaweicloud.com/blogs/307223

##### 数组的定义

同一种类型数据的集合

```
    // 第一种  数组的定义  定义一个存储3个整数的容器
	int [] x = new int[3];
	// 第二种  数组的定义  定义一个存储3个整数的容器
	int [] y = new int[] {2,7,6,9,4,3,3};
	// 第三种  数组的定义  定义一个存储3个整数的容器
	int [] z = {2,7,6,9,4,3,3};

        // 数组定义，二维数组
	// 第一种  数组的定义  
		int [][] arr4 = new int[3][5];
	// 第二种  数组的定义  
		int [][] arr5 = new int[][] {{-2,7,6},{-9,4,3,3}};
	// 第三种  数组的定义  
		int [][] arr6= {{-2,7,6},{-9,4,3,3}};
```

##### 数组的操作

```
package base;

public class Array_learn {
public static void main(String[] args) {
	// 数组定义，一维数组
	// 第一种  数组的定义  定义一个存储3个整数的容器
	int [] arr1 = new int[3];
	// 第二种  数组的定义  
	int [] arr2 = new int[] {-2,7,6,-9,4,3,3};
	// 第三种  数组的定义  
	int [] arr3= {2,7,6,9,4,3,3};
	
	// 数组定义，二维数组
	// 第一种  数组的定义  
		int [][] arr4 = new int[3][5];
	// 第二种  数组的定义  
		int [][] arr5 = new int[][] {{-2,7,6},{-9,4,3,3}};
	// 第三种  数组的定义  
		int [][] arr6= {{-2,7,6},{-9,4,3,3}};
	
	// 打印数组
	printArray(arr2);
	//获取数组中的最大值
	int max = getArrayMax(arr2);
	System.out.println(max);
	//获取数组中的最小值
	int min = getArrayMin(arr2);
	System.out.println(min);
	// 数组的排序之冒泡排序
	bubbleSort(arr2);
	printArray(arr2);
	// 数组的排序之插入排序
	insertSort(arr2);
	printArray(arr2);
	// 数组的排序之选择排序
	selectSort(arr2);
	printArray(arr2);
	// 数组的查找之折半查找
	// 因为折半查找要求数组必须有序，所以先进行排序
	selectSort(arr2);
	int m = halfSearch(arr2,7);	
	System.out.println(m);	// 返回查找的数组下标，如果没有找到返回-1
	}
	// 打印数组
	public static void printArray(int[] y){
		for(int i =0; i < y.length; i++)
		{
			System.out.print(y[i]+"\t");
		}
		System.out.println();
	}
	// 获取数组中的最大值
	public static int getArrayMax(int[] y){
		int max = y[0];
		for(int i = 0; i < y.length; i++){
			if(y[i]>max){
				max =y[i];
			}
		}
		return max;	
	}
	//获取数组中的最小值
	public static int getArrayMin(int[] y){
		int min = y[0];
		for(int i = 0; i < y.length; i++){
			if(y[i]<min){
				min =y[i];
			}
		}
		return min;	
	}
	// 数组的排序之冒泡排序
	public static void bubbleSort(int[] y) {
		/**
		冒泡排序
		比较相邻的元素。如果第一个比第二个大，就交换他们两个。 [1] 
		对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 [1] 
		针对所有的元素重复以上的步骤，除了最后一个。 [1] 
		持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
		**/
		int temp = 0;
		// 外层循环，它决定一共走几趟
		for (int i = 0; i < y.length-1; ++i) {
		//内层循环，它决定每趟走一次
		for (int j = 0; j < y.length-i-1; ++j) {
		//如果后一个大于前一个  	换位
		if (y[j + 1] < y[j]) {
			temp = y[j];
			y[j] = y[j + 1];
			y[j + 1] = temp;
			}
		}	
	 }
	}
	// 数组的排序之插入排序
	public static void insertSort(int y[]) {
		int i, j;
		for (i = 1; i < y.length; i++) {
		int temp = y[i];
		for (j = i; j > 0 && temp < y[j - 1]; j--) {
		y[j] = y[j - 1];
		}
		y[j] = temp;
		}
		}
	// 数组的排序之选择排序
	public static void selectSort(int y[]) {
		int temp = 0;
		for (int i = 0; i < y.length - 1; i++) {
		// 认为目前的数就是最小的, 记录最小数的下标
		int minIndex = i;
		for (int j = i + 1; j < y.length; j++) {
		if (y[minIndex] > y[j]) {
		// 修改最小值的下标
		minIndex = j;
		}
		}
		// 当退出for就找到这次的最小值
		if (i != minIndex) {
		temp = y[i];
		y[i] = y[minIndex];
		y[minIndex] = temp;
		   }
		}
	}
	// 数组的查找之折半查找
	public static int halfSearch(int[] arr,int target) {
		//定义三个变量分别记录最大、最小、中间的查找范围索引值
		int max=arr.length-1;
		int min=0;
		int mid=(max+min)/2;
		while(true) {	
			if(target<arr[mid]) {		//如果目标元素小于中点元素
				max = mid-1;			//max向mid前移动
			}else if(target>arr[mid]) { //如果目标元素大于中点元素
				min = mid+1;			//min向mid后移动
			}else {
				return mid;				//找到目标元素
			}			
			//没有找到的情况
			if(max<min) {
				return -1;
			}			
			//重新计算中间索引值
			mid=(max+min)/2;
		}		
	}	
}
```

#### Javadoc 使用详解

https://blog.csdn.net/vbirdbest/article/details/80296136

## 面向对象

### 方法

#### 方法的概念

方法就是定义在类中的具有特定功能的一段独立代码（函数==方法）

方法的优点

- 减少代码冗余。
- 提高复用性。
- 提高可读性。
- 提高可维护性。
- 方便分工合作。

#### 方法的定义

```
修饰符 返回值类型 方法名（[参数类型1 参数名1,参数类型2 参数名2 ....]）{
    代码块.......
    return  返回值；    //返回值的类型必须与返回值类型一致
}
```

#### 方法的参数

形参：等同于局部变量
实参：

```
定义语法：
public static void 方法名称(形式参数){
      // 方法主体
}
调用语法
 方法名称(实际参数);
```

#### 方法的返回值与返回值类型

```
定义语法
public static 返回值类型 方法名称(形式参数列表){
        // 函数主体
    return value; // 返回值
}
调用语法
变量 = 方法名称();   // 变量类型与返回值类型一致
```

return关键字

- 用途
  （1）返回方法指定类型的值（前提是方法的返回值类型不是void）。
  （2）方法的结束，它会导致当前的方法退出。
- 使用形式
  （1）方法有返回值类型，格式：
                return 返回值;
  （2）方法没返回值类型，格式：
                return;

#### 方法的重载

在同一个类中，定义多个方法名相同、参数列表不同的方法。
调用时通过方法名和参数列表来确定一个方法,方法的重载和返回值类型无关。

```
public class Function_test {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
            int a = add(4,9);
            System.out.println(a);
            int b = add(4,9,4);
            System.out.println(b);
    }

    // add函数，获取两个值的和
    public static int add(int x,int y){
            int sum = x+y;
            return sum;
    }

    // add函数的重载 ,获取三个值的和
    public static int add(int x,int y,int z){
        int sum = x+y+z;
        return sum;
    }
}
```

#### 方法的重写

重载和重写的区别

> https://blog.csdn.net/LosingCarryJie/article/details/87736026

#### 方法的递归

函数的内部调用自身的过程

```
// 斐波那契数列
public class RecursionFibonacci {
public static void main(String[] args) {
	// 1 1 2 3 5 8 13 21 34 55 89
	Scanner sc = new Scanner(System.in);
	System.out.println("请输入fibonacci的项数：");
	int inpu = sc.nextInt();	
	int result = fibonacci(inpu);
	System.out.println(result);
}
public static int  fibonacci(int n){
	if (n == 0){
		return 0;
	}else if(n==1) {
		return 1;
	}
	return fibonacci(n-1)+fibonacci(n-2);
	}
}
```

递归输出文件目录名

```
public class RecursionFileName {   
public static void main(String[] args) {
        String path = "D:/";                   // 设定文件路径
        test(path);
    }
    private static void test(String path) {			// 输出文件目录函数
        File f = new File(path);				// 创建一个文件路径对象
        File[] fs = f.listFiles();				// 创建文件路径列表的数组
        if (fs == null) {						// if数组为空，则返回
            return;
        }
        for (File file : fs) {					// 输出数组
            if (file.isFile()) {
                System.out.println(file.getPath());
            } else {
                test(file.getPath());
            }
        }
    }
}
```

### 构造方法

> https://bbs.huaweicloud.com/blogs/308778
>
> 
>
> https://bbs.huaweicloud.com/blogs/311916
>
> 
>
> https://blog.csdn.net/qq_47897078/article/details/120243801





### 初始化

#### 类初始化

#### 成员初始化

#### 构造方法初始化

#### 初始化顺序

#### 数组初始化

### 封装

- 为了不直接被外部使用，提高代码的安全性
- 就是降低类的使用者的学习成本，不需要知道类的实现，只需要学会调用就好了

### 继承



### 多态

### 关键字

#### final

#### static

#### this

#### super

#### volatile

#### synchronized

#### transient

> https://zhuanlan.zhihu.com/p/284345618







### 内部类

#### 内部类有坑，100%内存泄露！

> https://mp.weixin.qq.com/s/ws13ccJF5BQyfjuk3VuXFg





## 泛型

> https://bbs.huaweicloud.com/blogs/326364

### 类型擦除

> https://bbs.huaweicloud.com/blogs/362220





## 注解

## 反射

通过反射修改String的值

```
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        String s = "abc";

        // 反射
        Field value = s.getClass().getDeclaredField("value");
        value.setAccessible(true);
        value.set(s,"abcd".toCharArray());

        System.out.println(s);
    }
```









## 文件

## 正则表达式

## 集合

### 遍历Map集合

> https://bbs.huaweicloud.com/blogs/300649

### 数组和List相互转换

> https://bbs.huaweicloud.com/blogs/300641



### ArrayList

> 源码分析1
>
> https://blog.csdn.net/qq_40399646/article/details/113806756
>
> 1、EMPTY_ELEMENTDATA 和 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 的区别
>
> *  EMPTY_ELEMENTDATA 创建一个大小为0的 list （容量从0开始）
> *  DEFAULTCAPACITY_EMPTY_ELEMENTDATA 创建一个默认空参 list （容量从10开始）
>
> 2、ArrayList 为什么要将存储数据的数组用 transient 修饰？
>
> *  1、ArrayList 会扩容
> *  2、ArrayList 的元素可以进行删除
> *  3、ArrayList 容量并不会缩容
> *  减少Null值的序列化到硬盘，优化存储空间
>
> 比如：一个 ArrayList 里有1000个值，存储1000个值，但删除999个之后，剩下一个值
>
> 此时，如果使用jdk自带序列化，需要序列化1000个值（999个null）
>
> ArrayList 自己实现了序列化方法 writeObject() 只需要序列化1个值



### LinkedList

> https://blog.csdn.net/K_520_W/article/details/122550485



### HashMap



### LinkedHashMap



### TreeMap











## 常用类

### Object

> https://blog.csdn.net/hyh17808770899/article/details/110956045

### Integer

> https://blog.csdn.net/Herishwater/article/details/101317700
>
> https://blog.csdn.net/Huang1178387848/article/details/111480137

### String

> https://bbs.huaweicloud.com/blogs/279319
>
> https://blog.csdn.net/qq_34287953/article/details/82021991

#### String.intern()

> https://blog.csdn.net/tianyuzui6/article/details/124417267



### 日期时间

> https://bbs.huaweicloud.com/blogs/280476

### Arrays

> https://blog.csdn.net/en_joker/article/details/102651217



### StringBuffer和StringBuilder

>https://bbs.huaweicloud.com/blogs/280641

### Decimal



### DecimalFormat

> https://blog.csdn.net/lly1122334/article/details/89761931

### LongAdder

>  https://blog.51cto.com/u_14518853/4893881



### 其他

> https://bbs.huaweicloud.com/blogs/280961



## 网络

### 拔掉网线后， 原本的 TCP 连接还存在吗？

> https://mp.weixin.qq.com/s/rmLezj4_EcCMB-MaQ361oQ

### 网关系统

> https://mp.weixin.qq.com/s/bBdjGt4eZ3sZTG_y56eCIQ

## 多线程

### ThreadLocal详解

> https://mp.weixin.qq.com/s/klhLeoVgPKzRoTVSBmjFFA





### Java多线程四种常用创建方式

> https://bbs.huaweicloud.com/blogs/279132

### 什么是线程安全的

当多个线程访问一个类时 ，如果不用考虑这些线程在运行时环境下的调度和交替执行，并且不需要额外的同步以及在调用方式代码不必作其他的协调，这个类的行为仍然是正确的，那么称为线程安全的。

一个对象的**状态** 就是它的**数据** ，存储在状态变量中，比如实例域或者静态域，对象的状态还包括了其他附属对象的域。

**所谓共享，就是指的是一个变量可以被多个线程访问；所谓可变就是指变量的值在器生命周期内可以改变。我们讨论的线程安全性好像是关于代码的，但是我们真正要做的事情是在不可控制的并发访问中保护数据。**

一个对象是否应该是线性安全的取决于它是否被多个线程访问。线程安全的这个性质，取决于程序中如何使用对象，而不是对象完成了什么。保证对象的形成安全性需要使用同步来协调对其他可变状态的访问。如果做不到这一点，就会导致肮脏数据的参数的产生和其他不可预见的结果。

在没有同步的情况下，如果多个线程访问了同一个变量，你的程序就存在隐患了。有三个方法来修复它：

**不要跨线程共享数据**

**使用状态变量变为不可不的那种。**

**在任何访问状态下变量的时候使用同步**

 

### 线程池

#### 优点

- 重复利用线程
  - 可以复用线程，降低了创建和销毁的性能开销
  - 提升任务的响应速度，当有新任务需要执行时不需创建线程可以立即执行
- 控制线程的数量
  - 可以根据系统承受能力，通过合理的控制线程数，防止线程数过多导致服务崩溃。
  - 线程池可以对线程进行统一的管理，支持更多的功能。

#### 实现原理

- 1）线程池管理器：用于创建并控制线程数量，包括创建线程和销毁线程；
- 2）工作线程：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
- 3）任务队列：用于缓存提交的任务。
- 4）任务拒绝策略：如果任务队列已满且线程数已达到上限，则需要有相应的拒绝策略来处理后续任务。

#### 线程池的5种状态

- 1）RUNNING：运行状态。接受新任务并且处理阻塞队列里的任务。
- 2）SHUTDOWN：拒绝新任务但是处理阻塞队列里的任务。
- 3）STOP：拒绝新任务并且抛弃阻塞队列里的任务，同时会中断正在处理的任务。
- 4）TIDYING：所有任务都执行完（包含阻塞队列里面的任务）后当前线程池活动线程数为0，将调用terminated方法。
- 5）TERMINATED：终止状态。terminated方法调用完成以后的状态。

#### ThreadPoolExecutor

##### 工作流程

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221230_161022.jpg)

##### execute()

提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。

##### submit()

用于提交需要返回值的任务。

##### shutdown()

关闭线程池，这时线程池不再接收新的任务，线程池中的所有任务（包括正在执行的和等待队列中的）完成后，线程池关闭

##### shutdownNow()

立即关闭线程池，这时线程池不再接收新的任务，线等待队列中的线程将不会被执行，并尝试中断正在运行的线程。









## Java 8

### 方法引用与构造器引用

> https://bbs.huaweicloud.com/blogs/308272

### 函数式接口

> https://bbs.huaweicloud.com/blogs/308271

### Lambda表达式

> https://bbs.huaweicloud.com/blogs/308270



# 框架

## java框架

### Spring Security

#### Spring Security 最佳实践

> https://mp.weixin.qq.com/s/3_x3FaphCjUVL0KHza9ivg
>
> https://www.pudn.com/news/6318191d88df2007aa388a72.html



### SpringBoot

#### Spring Validation的使用

> https://jishuin.proginn.com/p/763bfbd6f5d5

#### SpringBoot封装响应数据和异常处理

> https://mp.weixin.qq.com/s/-XrKZkrYV1ejvNN4GxCfXA

#### SpringBoot 时间格式化的 5 种实现方法！

> https://blog.csdn.net/weixin_44016938/article/details/126382747

#### SpringBoot 项目优雅实现 Excel 导入导出功能

> https://mp.weixin.qq.com/s/gAIFceDOFqiyVu0ckZyfjQ

#### SpringBoot 设置动态定时任务

> https://mp.weixin.qq.com/s/Kc64nDZ4c8yuF5HtdssrcQ

### SpringCloud

#### SpringCloud问题

> https://mp.weixin.qq.com/s/xHJCQt97RNdGrf0VnTT_kA

# 中间件

## mybatis



## MyBatis-Plus

### MyBatis-Plus常用API全套教程，看完没有不懂的

> https://mp.weixin.qq.com/s/X7yolbcYUPiHXJ-n-xjvwQ

### 利用线程特性与ThreadLocal来解决公共字段自动填充问题

> https://mp.weixin.qq.com/s/SKepcX66oNQqmXr2BG8Kpw

## 数据库

### MySQL

#### MySql基础

> https://bbs.huaweicloud.com/blogs/293305

#### MySQL replace()字符串替换函数的使用

> https://www.cnblogs.com/kegui/p/16642909.html

#### mysql 最大建议行数 2000w, 靠谱吗？

> https://mp.weixin.qq.com/s/dTvVbtt3F9GQyCvjx2bHGw

#### 关于MySQL中查询后删除

https://blog.csdn.net/weixin_38004638/article/details/107078588

```
MySQL查询后删除问题
SELECT
	p.* 
FROM
	tb_open_parameter p
	LEFT JOIN tb_open_service_parameter_rel r ON r.PARAMETER_ID = p.PARAMETER_ID
	LEFT JOIN tb_open_service_info i ON i.SERVICE_ID = r.SERVICE_ID 
WHERE
	ESB_METHOD LIKE 'xiao%'
	
SELECT
	r.* 
FROM
	tb_open_service_parameter_rel r
	LEFT JOIN tb_open_service_info i ON i.SERVICE_ID = r.SERVICE_ID 
WHERE
	ESB_METHOD LIKE 'xiao%'
	
SELECT
	* 
FROM
	tb_open_service_info 
WHERE
	ESB_METHOD LIKE 'xiao%'
	
DELETE 
FROM
	tb_open_parameter 
WHERE
	PARAMETER_ID IN (
	SELECT
		tt.PARAMETER_ID 
	FROM
		(
		SELECT
			p.parameter_id 
		FROM
			tb_open_parameter p
			LEFT JOIN tb_open_service_parameter_rel r ON r.PARAMETER_ID = p.PARAMETER_ID
			LEFT JOIN tb_open_service_info i ON i.SERVICE_ID = r.SERVICE_ID 
		WHERE
			ESB_METHOD LIKE 'xiao%' 
		) tt 
	)

DELETE FROM  tb_open_service_parameter_rel
WHERE SERVICE_ID in
(
	 SELECT 
			tt.SERVICE_ID
	 FROM
	  (
			select r.SERVICE_ID
			FROM tb_open_service_parameter_rel r
			LEFT JOIN tb_open_service_info i on  i.SERVICE_ID = r.SERVICE_ID
			WHERE ESB_METHOD like 'xiao%'
		) tt
)

DELETE FROM  tb_open_service_info
WHERE SERVICE_ID in
(
	 SELECT 
			tt.SERVICE_ID
	 FROM
	  (
			select SERVICE_ID
			FROM
		
				tb_open_service_info
			WHERE 
				ESB_METHOD like 'xiao%'
		) tt
)
```



### SQL优化

#### 1、explain

##### Extra

- using index：SQL所需要的返回值所有列数据均在一颗索引树上，即无需访问实际的行记录
- using where：SQL使用了where过滤条件

注：使用了where条件的SQL，并不代表不需要优化，需要进一步判断explain执行计划中type的类型，如果type为all，表示进行了全表扫描，则需要优化，否则不需要优化

- using index condition：说明检索确实命中索引，但不是所有的列都在索引树上，还有需要访问实际的行记录，这个SQL语句性能也很高，但不如using index
- using filesort：得到的所有的结果集，需要进行文件排序，SQL语句性能很差，需要优化

##### select_type

- SIMPLE(简单查询。查询不包含子查询和union)
- PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)
-  UNION(UNION中的第二个或后面的SELECT语句)
-  DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)
-  UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)
- SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)
- DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)
- DERIVED(派生表的SELECT, FROM子句的子查询)
-  UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)

##### Table

这一列表示 explain 的一行正在访问哪个表

##### possible_keys 和 key

possible_keys这一列显示查询可能使用哪些索引来查找，key是真正使用的索引。
explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。

##### type

- system：表仅有一行，基本用不到；
- const：表最多一行数据配合，主键查询时触发较多；
- eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型；
- ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取；
- range：只检索给定范围的行，使用一个索引来选择行。当使用=、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range；

- index：该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小；

- all：全表扫描；

- 性能排名：system > const > eq_ref > ref > range > index > all。

- 实际sql优化中，最后达到ref或range级别。

#### 2、避免在where子句中使用 or 来连接条件

反例

```
SELECT * FROM user WHERE id=1 OR salary=5000
```

正例

使用union all或者分两条SQL写

```
SELECT * FROM user WHERE id=1 
UNION ALL
SELECT * FROM user WHERE salary=5000

SELECT * FROM user WHERE id=1
SELECT * FROM user WHERE salary=5000
```

使用`or`可能会使索引失效，从而全表扫描；

对于`or`没有索引的`salary`这种情况，假设它走了`id`的索引，但是走到`salary`查询条件时，它还得全表扫描；

也就是说整个过程需要三步：全表扫描+索引扫描+合并。如果它一开始就走全表扫描，直接一遍扫描就搞定；

虽然`mysql`是有优化器的，出于效率与成本考虑，遇到`or`条件，索引还是可能失效的；

#### 3、使用数值替代字符串类型

- 因为引擎在处理查询和连接时会逐个比较字符串中每一个字符；

- 而对于数字型而言只需要比较一次就够了；

- 字符会降低查询和连接的性能，并会增加存储开销；

#### 4、使用varchar代替char

- varchar`变长字段按数据内容实际长度存储，存储空间小，可以节省存储空间；

- char`按声明大小存储，不足补空格；

- 其次对于查询来说，在一个相对较小的字段内搜索，效率更高；

#### 5、避免在where子句中使用!=或<>操作符

- 使用`!=`和`<>`很可能会让索引失效

- 应尽量避免在`where`子句中使用`!=`或`<>`操作符，否则引擎将放弃使用索引而进行全表扫描

- 实现业务优先，实在没办法，就只能使用，并不是不能使用

#### 6、提高group by语句的效率

先过滤，后分组，可以在执行到该语句前，把不需要的记录过滤掉

```
SELECT
	job， avg（ salary） 
FROM
	employee 
WHERE
	job = 'develop'
GROUP BY job;
```

#### 7、优化like语句

```
select * from citys where name like '大连%' (使用索引) 。
```

- 首先尽量避免模糊查询，如果必须使用，不采用全模糊查询，也应尽量采用右模糊查询， 即`like ‘…%’`，是会使用索引的；
- 左模糊`like ‘%...’`无法直接使用索引，但可以利用`reverse + function index`的形式，变化成 `like ‘…%’`；
- 全模糊查询是无法优化的，一定要使用的话建议使用搜索引擎。

#### 8、查询SQL尽量不要使用select \*，而是具体字段

```
SELECT
	id, username,phone 
FROM
	tb_sys_org
```





### 分库分表

#### SpringBoot做MySQL分库分表

> https://www.pudn.com/news/631e930ef0cde61357459786.html
>
> https://mp.weixin.qq.com/s/-HWpqaee33sk7SU4DgGzHQ

#### SpringBoot + Sharding JDBC，一文搞定分库分表、读写分离

https://mp.weixin.qq.com/s/jUnyL8vLk-owFSu1TzMA2A





































# 数据结构和算法

## 数组和链表

> https://www.cnblogs.com/54chensongxia/p/11474539.html

## 栈

> https://blog.csdn.net/weixin_53227758/article/details/123000527



## 排序算法

> https://www.cnblogs.com/xiaozhongfeixiang/p/11751494.html
>
> https://www.sohu.com/na/421549356_99979179

### 分类

- 比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。

- 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221122_110233.jpg)

### 复杂度 

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221122_110443.jpg)

- 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。

### 冒泡排序

两两比较相邻的关键码，如果反序则交换，直到没有反序的记录为止

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221121_145656.jpg)

```
/**
 * @Description 冒泡排序
 * @Author huangxiao
 * @Date 2022-11-16
 */
public class BubbleSort {
    public static void main(String[] args) {
        int[] sortArray = {10, 23, 11, 56, 45, 26, 59, 28, 84, 79, 1, 5, 3, 89, 45, 26, 23, 11};
        outputArray(sortArray);

        for (int i = 0; i < sortArray.length - 1; i++) {
            for (int j = 0; j < sortArray.length - i - 1; j++) {
                if (JudgeSize(sortArray[j], sortArray[j + 1])) {
                    changePosition(j, sortArray);
                }
            }
            outputArray(sortArray, i + 1);
        }

        outputArray(sortArray);
    }

    /**
     * 数组输出
     */
    public static void outputArray(int[] inputArray) {
        System.out.println("数组遍历输出：");
        for (int value : inputArray) {
            System.out.print(value + "  ");
        }
        System.out.println();
    }

    /**
     * 数组输出
     */
    public static void outputArray(int[] inputArray, int num) {
        System.out.println("第" + num + "次输出数组：");
        for (int value : inputArray) {
            System.out.print(value + "  ");
        }
        System.out.println();
    }

    /**
     * 判断大小
     */
    public static boolean JudgeSize(int num1, int num2) {
        return num1 > num2;
    }

    /**
     * 交换位置
     */
    public static int[] changePosition(int num, int[] sortArray) {
        int temp = sortArray[num];
        sortArray[num] = sortArray[num + 1];
        sortArray[num + 1] = temp;
        return sortArray;
    }
}
```

### 快速排序

> https://blog.csdn.net/zhuxian1277/article/details/112466047

首先选定一个轴值（就是比较的基准），将待排序记录分割成独立的两部分，左侧记录的关键码都小于或是等于轴值，右侧的记录关键码都大于或等于轴值，然后在对这两部分分别重复上述的过程，直到整个序列有序。

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221121_161738.jpg)

```
/**
 * @Description 快速排序
 * @Author huangxiao
 * @Date 2022-11-21
 */
public class QuickSort {
    public static void main(String[] args) {
        int[] array = {6, 4, 7, 56, 23, -101, -77, -1, 0, 5, 0, 100};
        outputArray(array);
        quickSort(array, 0, array.length - 1);
        outputArray(array);
    }

    public static void quickSort(int[] array, int left, int right) {
        if (left >= right) {
            return;
        }
        // 先求出基准数的下标
        int index = sort(array, left, right);
        if (index != 0) {
            // 对基准数左边递归
            quickSort(array, left, index - 1);
            // 对基准数右边递归
            quickSort(array, index + 1, right);
        }
    }

    /**
     * left，左边界.
     * right,右边界.范围array.length-1
     */
    public static int sort(int[] array, int start, int end) {
        // 找出一个基准数,使得左边的数<=基准数,基准数>=右边的数,返回此基准数下标
        // 假设第一个数就是基准数
        int s = start;
        while (start < end) {
            // 从右边开始找到小于等于基准数的
            while (start < end && array[end] > array[s]) {
                end--;
            }
            // 从左边开始找到大于基准数的
            while (start < end && array[s] >= array[start]) {
                start++;
            }
            // end>start 说明小于等于基准数还在右边,大于基准数的在左边,两两交换即可
            if (end > start) {
                swap(array, start, end);
            }
        }
        swap(array, s, start);
        return start;
    }

    /**
     * 交换位置
     */
    public static void swap(int[] sortArray, int start, int end) {
        int temp = sortArray[start];
        sortArray[start] = sortArray[end];
        sortArray[end] = temp;
    }

    /**
     * 数组输出
     */
    public static void outputArray(int[] inputArray) {
        System.out.println("数组遍历输出：");
        for (int value : inputArray) {
            System.out.print(value + "  ");
        }
        System.out.println();
    }
}
```

> 解决Exception in thread “main” java.lang.StackOverflowError
>
> https://blog.csdn.net/weixin_44917577/article/details/117200555

### 选择排序

每趟排序在当前待排序序列中选出关键码最小的记录，添加到有序序列中。

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221121_165518.jpg)

```
/**
 * @Description 选择排序
 * @Author huangxiao
 * @Date 2022-11-21
 */
public class SelectSort {
    public static void main(String[] args) {
        int[] array = {6, 4, 7, 56, 23, -101, -77, -1, 0, 5, 0, 100};
        outputArray(array);
        selectSort(array, 0);
        outputArray(array);
    }

    public static void selectSort(int[] array, int index) {
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = i + 1; j < array.length - 1; j++) {
                if (array[j] < array[index]) {
                    index = j;
                }
            }
            if (index != i) {
                swap(array, i, index);
            }
        }
    }

    /**
     * 交换位置
     */
    public static void swap(int[] sortArray, int start, int end) {
        int temp = sortArray[start];
        sortArray[start] = sortArray[end];
        sortArray[end] = temp;
    }

    /**
     * 数组输出
     */
    public static void outputArray(int[] inputArray) {
        System.out.println("数组遍历输出：");
        for (int value : inputArray) {
            System.out.print(value + "  ");
        }
        System.out.println();
    }
}
```

### 堆排序

> https://blog.csdn.net/fengyuyeguirenenen/article/details/125112681

```
/**
 * @Description 堆排序
 * @Author huangxiao
 * @Date 2022-11-21
 */
public class HeapSort {
    public static void main(String[] args) {
        int[] array = {4, 6, 8, 78, 13, 19, 1, 5, 9,};
        outputArray(array);
        heapSort(array);
        outputArray(array);
    }

    public static void heapSort(int[] array) {
        // 从倒数第一个非叶子节点开始
        for (int i = array.length / 2 - 1; i >= 0; i--) {
            // 从第一天非叶子节点从下至上，从左至右调整结构
            adjustHeap(array, i, array.length);
        }
        // 将堆顶元素与末尾元素交换 将最大元素沉到数组末尾 + 重新调整堆结构
        for (int i = array.length - 1; i > 0; i--) {
            // 交换堆顶元素和末尾元素
            swap(array, 0, i);
            // 交换后的末尾元素忽略(j--) 不再参与堆结构的调整
            // 重新调整堆结构
            adjustHeap(array, 0, i);
        }
    }

    public static void adjustHeap(int[] array, int index, int length) {
        // 取出当前元素
        int temp = array[index];
        // i节点是index节点的左子节点
        for (int i = 2 * index + 1; i < length; i = 2 * i + 1) {
            // 表明左子节点小于右子节点
            if (i + 1 < length && array[i] < array[i + 1]) {
                // 将指针移至较大节点
                i++;
            }
            // 如果子节点大于父节点
            if (array[i] > temp) {
                // 将较大值赋给当前节点
                array[index] = array[i];
                // 指针移向子节点
                index = i;
            } else {
                break;
            }
        }
        // 循环结束，已经将最大值放在了堆顶
        // 将temp值放到最终的位置
        array[index] = temp;
    }

    /**
     * 交换位置
     */
    public static void swap(int[] sortArray, int start, int end) {
        int temp = sortArray[start];
        sortArray[start] = sortArray[end];
        sortArray[end] = temp;
    }

    /**
     * 数组输出
     */
    public static void outputArray(int[] inputArray) {
        System.out.println("数组遍历输出：");
        for (int value : inputArray) {
            System.out.print(value + "  ");
        }
        System.out.println();
    }
}
```

### 插入排序

> https://blog.csdn.net/m0_66435981/article/details/124282325

每次将一个待排序的记录按其关键码的大小插入到一个已经排好序的有序序列中，直到全部记录排好序。

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20221121_173902.jpg)

```
/**
 * @Description 插入排序
 * @Author huangxiao
 * @Date 2022-11-21
 */
public class InsertSort {
    public static void main(String[] args) {
        int[] array = {6, 4, 7, 56, 23, -101, -77, -1, 0, 5, 0, 100};
        outputArray(array);
        insertSort(array);
        outputArray(array);
    }

    public static void insertSort(int[] array) {
        for (int i = 0; i < array.length; i++) {
            int temp = array[i];
            int j = i - 1;
            for (; j >= 0; j--) {
                if (array[j] > temp) {
                    array[j + 1] = array[j];
                } else {
                    // array[j+1]=tmp;
                    break;
                }
            }
            array[j + 1] = temp;
        }
    }

    /**
     * 数组输出
     */
    public static void outputArray(int[] inputArray) {
        System.out.println("数组遍历输出：");
        for (int value : inputArray) {
            System.out.print(value + "  ");
        }
        System.out.println();
    }
}
```

### 归并排序

> https://blog.csdn.net/weixin_50941083/article/details/120852477

### 希尔排序

### 计数排序

### 桶排序

### 基数排序











## 查找

### 二分查找

- 查询速度是非常快的，比较次数少，平均性能好。
- 缺点就是二分查找必须有个前提就是数组是有序的，而且插入删除都比较困难。

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/20210327152307712.gif)



```
    /**
     * Arrays类的binarySearch方法
     * 如果需要查找的数据存在，就返回数组中对应数据的下标值，
     * 如果不存在，返回值为：-（应该插入的位置索引+1）
     *
     * @param array     有序数组
     * @param searchNum 查找的数
     * @return 查找的数的下标
     */
    public static int binarySearch(int[] array, int searchNum) {
        return Arrays.binarySearch(array, searchNum);
    }

    /**
     * 迭代方式
     *
     * @param array     有序数组
     * @param searchNum 查找的数
     * @return 查找的数的下标
     */
    public static int binarySearchIteration(int[] array, int searchNum) {
        //初始化最小值的索引为0
        int left = 0;
        //初始化最大值的索引为arr.length-1
        int right = array.length - 1;
        //首尾相加再除以2得出中间索引
        int mid = (left + right) / 2;
        while (left <= right) { //确保程序不会重复查询，不会越界
            if (searchNum > array[mid]) {
                //如果查询的值比中间值大，则往右边区域找，就把最小索引改为中间索引右移一位
                left = mid + 1;
            } else if (searchNum < array[mid]) {
                //如果查询的值比中间值小，则往左边区域找，就把最大索引改为中间索引左移一位
                right = mid - 1;
            } else {
                //剩余的情况就是查询到了结果，那么就直接返回索引。
                return mid;
            }
            mid = (left + right) / 2;
        }
        //没有查询到，则返回-1
        return -1;
    }

    /**
     * 递归方式
     *
     * @param array     有序数组
     * @param searchNum 查找的数
     * @return 查找的数的下标
     */
    public static int binarySearchRecursion(int[] array, int searchNum) {
        //初始化最小值的索引为0
        int left = 0;
        //初始化最大值的索引为arr.length-1
        int right = array.length - 1;
        if (left > right) {
            return -1;
        }
        int mid = (left + right) / 2;
        if (array[mid] == searchNum) {
            return mid;
        } else if (array[mid] > searchNum) {
            return binarySearchRecursion(array, mid - 1);
        } else {
            return binarySearchRecursion(array, searchNum);
        }
    }
```





# 设计和结构

## 设计模式

## 架构

### 8种架构

> https://mp.weixin.qq.com/s/per0sigoPNTMYRr4oN1AVw

# 运维

# 分布式

# 工具

## GitHub

### 本地项目上传到github

#### 创建仓库

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20220829_112143.png)

#### 配置SSH Key

如果没有配置github，需要配置

#### 本地项目初始化

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20220829_112628.png)

#### 在终端下关联git仓库

运行：**git remote add origin git@github.com:【你的github用户名】/【仓库名称】.git**，例如`git remote add origin git@github.com:itmacy/cloud-note.git`

```
xiao@xiao MINGW64 /f/读书破万卷/xiao (master)
$  git remote add origin git@github.com:xiao2769433/xiao.git
```

#### 代码提交

- 把本地所有文件添加到缓冲区，运行：`git add .`
- 提交所有文件，运行：`git commit -m ‘添加项目’`
- 推送到git仓库，运行：`git push —set-upstream origin master`

## IDEA

### IDEA官网

> https://www.jetbrains.com/idea/

### IDEA断点调试技巧

> https://blog.51cto.com/u_15454291/5341117





## Lombok

### Lombok 同时使⽤ @Data 和 @Builder 的坑

Lombok原理

https://blog.csdn.net/afreon/article/details/125631273



# 程序员的自我修养

```
第一次做某件事时只管去做；
第二次做类似的事时会产生反感，但无论如何还是可以去做；
第三次再做类似的事时，你就应该重构。
```

## 优化

### 性能优化的 10 个技巧！

> https://mp.weixin.qq.com/s/SgSU53cY4LcLKZ3bKKluSg

### 消除if...else

> https://cloud.tencent.com/developer/article/1769479





### String.format()拼接字符串

请求地址拼接

```
String url = "http://127.0.0.1?userName="+userName+"&age="+age+"&address="+address+"&sex="+sex+"&roledId="+roleId;
```

使用`StringBuilder`拼接字符串

```
StringBuilder urlBuilder = new StringBuilder("http://127.0.0.1?");
urlBuilder.append("userName=")
.append(userName)
.append("&age=")
.append(age)
.append("&address=")
.append(address)
.append("&sex=")
.append(sex)
.append("&roledId=")
.append(roledId);
```

使用`String.format`方法优化

```
String requestUrl = "http://127.0.0.1?userName=%s&age=%s&address=%s&sex=%s&roledId=%s";
String url = String.format(requestUrl,userName,age,address,sex,roledId);
```

### 减少循环次数

在我们日常开发中，循环遍历集合是必不可少的操作。

但如果循环层级比较深，循环中套循环，可能会影响代码的执行效率。

`反例`：

```
for(User user: userList) {
   for(Role role: roleList) {
      if(user.getRoleId().equals(role.getId())) {
         user.setRoleName(role.getName());
      }
   }
}
```

这个例子中有两层循环，如果userList和roleList数据比较多的话，需要循环遍历很多次，才能获取我们所需要的数据，非常消耗cpu资源。

`正例`：

```
Map<Long, List<Role>> roleMap = roleList.stream().collect(Collectors.groupingBy(Role::getId));
for (User user : userList) {
    List<Role> roles = roleMap.get(user.getRoleId());
    if(CollectionUtils.isNotEmpty(roles)) {
        user.setRoleName(roles.get(0).getName());
    }
}
```

减少循环次数，最简单的办法是，把第二层循环的集合变成`map`，这样可以直接通过`key`，获取想要的`value`数据。

虽说map的key存在`hash冲突`的情况，但遍历存放数据的`链表`或者`红黑树`的`时间复杂度`，比遍历整个list集合要小很多。

### 初始化集合时指定大小

在实际项目开发中，需要经常使用集合，比如：ArrayList、HashMap等。

`反例`：

```
public class Test2 {

    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        long time1 = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            list.add(i);
        }
        System.out.println(System.currentTimeMillis() - time1);
    }
}
```

执行时间：

```text
12
```

如果在初始化集合时指定了大小。

`正例`：

```text
public class Test2 {

    public static void main(String[] args) {
        List<Integer> list2 = new ArrayList<>(100000);
        long time2 = System.currentTimeMillis();
        for (int i = 0; i < 100000; i++) {
            list2.add(i);
        }
        System.out.println(System.currentTimeMillis() - time2);
    }
}
```

执行时间：

```text
6
```

在创建集合时指定了大小，比没有指定大小，添加10万个元素的效率提升了一倍。

`ArrayList`源码，它的默认大小是`10`，如果添加元素超过了一定的阀值，会按`1.5`倍的大小扩容。

如果装10万条数据，需要扩容很多次，而每次扩容都需要不停的复制元素，从老集合复制到新集合中，需要浪费多少时间。

### 状态用枚举

在建的表中，有很多状态字段，比如：订单状态、禁用状态、删除状态等。

每种状态都有多个值，代表不同的含义。

比如订单状态有：

- 1：表示下单
- 2：表示支付
- 3：表示完成
- 4：表示撤销

如果没有使用枚举，一般是这样做的：

```text
public static final int ORDER_STATUS_CREATE = 1;
public static final int ORDER_STATUS_PAY = 2;
public static final int ORDER_STATUS_DONE = 3;
public static final int ORDER_STATUS_CANCEL = 4;
public static final String ORDER_STATUS_CREATE_MESSAGE = "下单";
public static final String ORDER_STATUS_PAY = "下单";
public static final String ORDER_STATUS_DONE = "下单";
public static final String ORDER_STATUS_CANCEL = "下单";
```

需要定义很多静态常量，包含不同的状态和状态的描述。

使用`枚举`定义之后，代码如下：

```text
public enum OrderStatusEnum {  
     CREATE(1, "下单"),  
     PAY(2, "支付"),  
     DONE(3, "完成"),  
     CANCEL(4, "撤销");  

     private int code;  
     private String message;  

     OrderStatusEnum(int code, String message) {  
         this.code = code;  
         this.message = message;  
     }  
   
     public int getCode() {  
        return this.code;  
     }  

     public String getMessage() {  
        return this.message;  
     }  
  
     public static OrderStatusEnum getOrderStatusEnum(int code) {  
        return Arrays.stream(OrderStatusEnum.values()).filter(x -> x.code == code).findFirst().orElse(null);  
     }  
}
```

使用枚举改造之后，职责更单一了。

而且使用枚举的好处是：

1. 代码的可读性变强了，不同的状态，有不同的枚举进行统一管理和维护。
2. 枚举是天然单例的，可以直接使用==号进行比较。
3. code和message可以成对出现，比较容易相关转换。
4. 枚举可以消除if...else过多问题。





## 陷阱与细节

### 对象比较方法

```
        Short shortValue = (short)12345;
        System.out.println(shortValue == 12345); // true
        Integer intValue = 12345;
        System.out.println(intValue == 12345); // true
        Long longValue =  12345L;
        System.out.println(longValue == 12345); // true
```

```
		Short shortValue = (short)12345;
        System.out.println(Objects.equals(shortValue,12345)); // false
        Integer intValue = 12345;
        System.out.println(Objects.equals(intValue,12345)); // true
        Long longValue = 12345L;
        System.out.println(Objects.equals(longValue,12345)); // false
```



- 保持良好的编码习惯，避免数据类型的自动转化
- 借助开发工具或插件，及早地发现数据类型不匹配问题
- 进行常规性单元测试，尽量把问题发现在研发阶段

### 三元表达式拆包

```
条件表达式？表达式 1：表达式 2;
如果条件表达式成立，则执行表达式1，否则执行表达式2
```

```
三元表达式的类型转化规则

• 若两个表达式类型相同，返回值类型为该类型；
• 若两个表达式类型不同，但类型不可转换，返回值类型为 Object 类型；
• 若两个表达式类型不同，但类型可以转化，先把包装数据类型转化为基本数据类型，然后按照基本数据类型的转换规则（byte<short(char)<int<long<float<double）来转化，返回值类型为优先级最高的基本数据类型。
```

```
        boolean condition = false;
        Double valuel = 1.0D;
        Double value2 = 2.0D;
        Double value3 = null;
        Double result = condition ? valuel * value2 : value3; // 抛出空指针异常
        
        boolean condition = false;
        double valuel = 1.0D;
        double value2 = 2.0D;
        double value3 = 3.0D;
        double result = condition ? valuel * value2 : value3;
```

- 如果三元表达式中有包装数据类型的算术计算，可以采用 if-else 语句代替
- 尽量使用基本数据类型，避免包装数据类型的拆装包

### 泛型对象赋值



### 泛型属性拷贝

```
BeanUtils.copyProperties 
```



### Set 对象排重



### 公有方法代理



### 公有字段代理







### for删除集合元素陷阱

> https://blog.csdn.net/Charles_7c/article/details/125660022

```
public class ForCycleCollection {

    public static void main(String[] args) {
        String temp = "xiao";
        ArrayList<String> forList = Lists.newArrayList("xiao", "xiao", "bu", "de", "mei", "shan");
        System.out.println(forList); // [xiao, xiao, bu, de, mei, shan]
        for (int i = 0; i < forList.size(); i++) {
            if (temp.equals(forList.get(i))) {
                forList.remove(i);
            }
        }
        System.out.println(forList);  // [xiao, bu, de, mei, shan]

        ArrayList<Integer> list = Lists.newArrayList(1, 2, 2, 3, 4);
        System.out.println(list);      // [1, 2, 2, 3, 4]
        for (int i = 0; i < list.size(); i++) {
            if (list.get(i) % 2 == 0) {
                list.remove(i);
                i--;
            }
        }
        System.out.println(list);   // [1, 3]

        ArrayList<Integer> list1 = Lists.newArrayList(1, 2, 2, 3, 4);
        System.out.println(list1);      // [1, 2, 2, 3, 4]
        for (int i = 0; i < list1.size(); i++) {
            if (list1.get(i) % 2 == 0) {
                i--;
                list1.remove(i);
            }
        }
        System.out.println(list1);   // [2, 4]
    }
}
```

### 浮点数差值损失

```
public static void main(String[] args) {
    /**
    * 精度丢失问题
    */
    double result = 3.00 - 2.61;
    System.out.println(result);   // 0.3900000000000001

    /**
    * BigDecimal 解决了浮点数相减错误的问题，但可能会造成程序运行速度的下降，因为该类并没有很好地得到Java语言的支持。
    */
    BigDecimal num1 = new BigDecimal("3.33");
    BigDecimal num2 = new BigDecimal("1.63");
    BigDecimal num3 = num1.subtract(num2);
    System.out.println(num3);   // 1.70
    double num3Double = num3.doubleValue();
    System.out.println(num3Double); // 1.7

    /**
    * 将 浮点数 转换为整数 提升效率
    */
    double num21 = 3.33D;
    double num22 = 1.39D;
    long num23 = (long) (num21 * 100);
    long num24 = (long) (num22 * 100);
    long resultNum = num23 - num24;
    double resultNum1 = resultNum/100.0;
    System.out.println(resultNum1);
}
```

### Java 中 |与||，&与&&的区别

> https://blog.csdn.net/zjt980452483/article/details/82688648

|| 与 && 都是短路功能：

(表达式一) || (表达式二)，则当表达式一为真，表达式二不执行。

(表达式一) && (表达式二)，则当表达式一位假，表达式二不执行。

对于&：无论&左边是否为false，他都会继续检验右边的boolean值。

对于&&:只要检测到左边Boolean值为false时，就会直接判断结果，不会在检验右边的值（因为"与"有一个false最后结果就是false了）

所以&&的执行效率更高，所以一般都是使用&&。

|与||之间也是同样的道理，|：无论左边是否为ture，都会检验右边 ，||：则不会。||  的执行效率会更高

### 默认构造方法并不都是public

- 默认构造方法的修饰符是与所在类的修饰符一致的，也就是说如果类是public的，默认构造方法的修饰符就是public的

- 如果类无修饰符，默认构造方法也将没有修饰符。

```
public class Test {
    public Test() {
    	super();
    }
}

class Test {
    Test() {
        super();
    }
}
```

### 实体类不要使用基本类型

（一）定义实体类时，如果属性的类型定义成int类型，在前台jsp页面数据呈现时，会默认显示为0.而Integer不会显示0.Integer是包装类，包装类符合对象的特征并提供了一些必要的属性和方法。

（二）如果返回字段值为null，int类型会报错，Integer不会报错。因为int类型声明的是变量，而null是对象所以会报错。

（三）int类型的默认值为0，Integer类型的默认值为null。

结论:在mybatis中，不要使用基本类型，要使用引用类型。









### 细数List的10个坑

> https://blog.csdn.net/m0_73311735/article/details/126890501







## 其他

### javap命令对代码进行反汇编

> https://blog.csdn.net/LosingCarryJie/article/details/88387962

查看电脑是否安装jdk以及安装了的路径

> https://www.cnblogs.com/damugua/p/16347387.html

‘javap‘ 不是内部或外部命令，也不是可运行的程序 或批处理文件。

> https://blog.csdn.net/weixin_45639532/article/details/115861764

### IDEA 查看代码反汇编代码

> https://blog.csdn.net/gaowenhui2008/article/details/116262133



### SQL查找是否"存在"

根据某一条件从数据库表中查询 『有』与『没有』

```
# 普通写法

# SQL写法
SELECT count(*) FROM table WHERE a = 1 AND b = 2

# Java写法
int nums = xxDao.countXxxxByXxx(params);
if ( nums > 0 ) {
  //当存在时，执行这里的代码
} else {
  //当不存在时，执行这里的代码
}
```

```
# 优化写法

# SQL写法
SELECT 1 FROM table WHERE a = 1 AND b = 2 LIMIT 1

# Java写法
Integer exist = xxDao.existXxxxByXxx(params);
if ( exist != NULL ) {
  //当存在时，执行这里的代码
} else {
  //当不存在时，执行这里的代码
}
```

SQL不再使用count，而是改用LIMIT 1，让数据库查询时遇到一条就返回，不要再继续查找还有多少条了 业务代码中直接判断是否非空即可





## 博客

### 1、程序员的酒后真言

> https://mp.weixin.qq.com/s/oJidlcwXMv37IJA2J_0tbA
>
> https://zhuanlan.zhihu.com/p/421168832

### 2、阿里禁用 boolean 类型变量用 isXxx 命名，why？

> https://mp.weixin.qq.com/s/OM3_q2xKq7o0JSXCk9sUvw





```
There are only two hard things in Computer Science: cache invalidation and naming things.

计算机科学中只有两件困难的事情：缓存失效和命名规范。

No code is the best way to write secure and reliable applications. Write nothing; deploy nowhere

不写代码，是编写安全可靠的应用程序的最佳方式。什么都不写；哪里都不部署。
```



# 读书笔记

## 《Java8实战》

> 资源下载地址
>
> https://github.com/RichardWarburton/java-8-Lambdas-exercises

### 行为参数化

```
public class FilteringApples {
    public static void main(String[] args) {
        List<Apple> inventory = Arrays.asList(new Apple(80, "green"), new Apple(99, "red"),
                new Apple(155, "green"), new Apple(120, "red"));

        // 筛选绿苹果
        List<Apple> greenApplesList = filterGreenApples(inventory);
        System.out.println("筛选绿苹果——>" + greenApplesList);

        // 根据颜色筛选苹果
        List<Apple> colorApplesList = filterApplesByColor(inventory, "red");
        System.out.println("根据颜色筛选苹果——>" + colorApplesList);

        // 根据重量筛选苹果
        List<Apple> weightApplesList = filterApplesByWeight(inventory, 150);
        System.out.println("根据重量筛选苹果——>" + weightApplesList);

        // 根据重量和颜色筛选苹果
        List<Apple> weightColorList = filterApples(inventory, "red", 150, true);
        System.out.println("根据重量和颜色筛选苹果——>" + weightColorList);
        List<Apple> weightAndColorList = filterApples(inventory, "red", 150, false);
        System.out.println("根据重量和颜色筛选苹果——>" + weightAndColorList);

        // 使用匿名类
        List<Apple> redApples = filterApples(inventory, new ApplePredicate() {
            public boolean test(Apple apple) {
                return "red".equals(apple.getColor());
            }
        });
        System.out.println("使用匿名类" + redApples);

        // 行为参数化
        List<Apple> redAndHeavyApples =
                filterApples(inventory, new AppleRedAndHeavyPredicate());
        System.out.println(redAndHeavyApples);

        // 使用 Lambda 表达式
        List<Apple> result =
                filterApples(inventory, (Apple apple) -> "red".equals(apple.getColor()));
        System.out.println("使用 Lambda 表达式" + result);

        // 将 List 类型抽象化
        List<Apple> redApples1 =
                filter(inventory, (Apple apple) -> "red".equals(apple.getColor()));
        System.out.println("将 List 类型抽象化" + redApples1);

    }

    // 筛选绿苹果
    public static List<Apple> filterGreenApples(List<Apple> inventory) {
        List<Apple> result = new ArrayList<Apple>();
        for (Apple apple : inventory) {
            if ("green".equals(apple.getColor())) {
                result.add(apple);
            }
        }
        return result;
    }

    // 根据颜色筛选苹果
    public static List<Apple> filterApplesByColor(List<Apple> inventory, String color) {
        List<Apple> result = new ArrayList<Apple>();
        for (Apple apple : inventory) {
            if (apple.getColor().equals(color)) {
                result.add(apple);
            }
        }
        return result;
    }

    // 根据重量筛选苹果
    public static List<Apple> filterApplesByWeight(List<Apple> inventory, int weight) {
        List<Apple> result = new ArrayList<Apple>();
        for (Apple apple : inventory) {
            if (apple.getWeight() > weight) {
                result.add(apple);
            }
        }
        return result;
    }

    // 根据重量和颜色筛选苹果
    public static List<Apple> filterApples(List<Apple> inventory, String color, int weight, boolean flag) {
        List<Apple> result = new ArrayList<Apple>();
        for (Apple apple : inventory) {
            if ((flag && apple.getColor().equals(color)) ||
                    (!flag && apple.getWeight() > weight)) {
                result.add(apple);
            }
        }
        return result;
    }

    // 参数化接口
    interface ApplePredicate {
        public boolean test(Apple a);
    }

    static class AppleWeightPredicate implements ApplePredicate {
        public boolean test(Apple apple) {
            return apple.getWeight() > 150;
        }
    }

    static class AppleColorPredicate implements ApplePredicate {
        public boolean test(Apple apple) {
            return "green".equals(apple.getColor());
        }
    }

    static class AppleRedAndHeavyPredicate implements ApplePredicate {
        public boolean test(Apple apple) {
            return "red".equals(apple.getColor())
                    && apple.getWeight() > 150;
        }
    }

    // 行为参数化
    public static List<Apple> filterApples(List<Apple> inventory, ApplePredicate p) {
        List<Apple> result = new ArrayList<>();
        for (Apple apple : inventory) {
            if (p.test(apple)) {
                result.add(apple);
            }
        }
        return result;
    }

    // 将 List 类型抽象化
    public interface Predicate<T> {
        boolean test(T t);
    }

    public static <T> List<T> filter(List<T> list, Predicate<T> p) {
        List<T> result = new ArrayList<>();
        for (T e : list) {
            if (p.test(e)) {
                result.add(e);
            }
        }
        return result;
    }
}
```

### Lambda表达式

优点

-  匿名——我们说匿名，是因为它不像普通的方法那样有一个明确的名称：写得少而想得多！ 
-  函数——我们说它是函数，是因为Lambda函数不像方法那样属于某个特定的类。但和方 法一样，Lambda有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表。 
-  传递——Lambda表达式可以作为参数传递给方法或存储在变量中。 
-  简洁——无需像匿名类那样写很多模板代码。

缺点

- lambda表达式可以使代码看起来简洁，但一定程度上增加了代码的可读性以及调试的复杂性，所以在使用时应尽量是团队都熟悉使用，要么干脆就别用，不然维护起来是件较痛苦的事。

Lambda表达式组成

-  参数列表 
-  箭头——（箭头->把参数列表与Lambda主体分隔开）
-  Lambda主体

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211227_143732.png)

```
public class Test {
    public static void main(String[] args) {
        // 使用Lambda
        Runnable r1 = () -> System.out.println("Hello World 1");

        // 使用匿名类
        Runnable r2 = new Runnable() {
            public void run() {
                System.out.println("Hello World 2");
            }
        };
        process(r1);
        process(r2);
        process(() -> System.out.println("Hello World 3"));
    }

    public static void process(Runnable r) {
        r.run();
    }
}
```

### 函数式接口

函数式接口：只定义一个抽象方法的接口

```
@FunctionalInterface
interface ApplePredicate {
	public boolean test(Apple a);
}
```

常见的函数式接口

Predicate

```
public class Test {
    public static void main(String[] args) {
        List<String> listOfStrings1 = Arrays.asList("kegui", "wu", "jia", "");
        Lambdas.Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
        List<String> nonEmpty = filter(listOfStrings1, nonEmptyStringPredicate);
        System.out.println(nonEmpty);
    }
    
    // 函数式接口 Predicate
    @FunctionalInterface
    public interface Predicate<T> {
        boolean test(T t);
    }

    public static <T> List<T> filter(List<T> list, Lambdas.Predicate<T> p) {
        List<T> results = new ArrayList<>();
        for (T s : list) {
            if (p.test(s)) {
                results.add(s);
            }
        }
        return results;
    }
}
```

Consumer

```
public class Test {
    public static void main(String[] args) {
        forEach(Arrays.asList(1,2,3,4,5), System.out::println);
    }

    @FunctionalInterface
    public interface Consumer<T>{
        void accept(T t);
    }
    public static <T> void forEach(List<T> list, Lambdas.Consumer<T> c){
        for(T i: list){
            c.accept(i);
        }
    }
}
```

Function

```
public class Test {
    public static void main(String[] args) {
        List<Integer> length = map(Arrays.asList("lambdas", "in", "action"), String::length);
        System.out.println(length);
    }

    // 函数式接口 Function
    @FunctionalInterface
    public interface Function<T, R> {
        R apply(T t);
    }

    public static <T, R> List<R> map(List<T> list, Function<T, R> f) {
        List<R> result = new ArrayList<>();
        for (T s : list) {
            result.add(f.apply(s));
        }
        return result;
    }
}
```

### 流

优点

- ❑ 声明性——更简洁，更易读
- ❑ 可复合——更灵活
- ❑ 可并行——性能更好

流操作

- 中间操作

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20230118_164401.jpg)

- 终端操作

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20230118_164416.jpg)

#### 外部迭代与内部迭代

- 外部迭代：由用户来决定”做什么“和”怎么做“的操作
- 内部迭代：只需要提供”做什么“，把”怎么做“的任务交给了 `JVM`

#### 数值流与构建流

> https://blog.csdn.net/qq_36602071/article/details/126865416

由值创建流

```
Stream<String> stream=Stream.of("Java 8 ", "Lambdas ", "In ", "Action");
stream.map(String::toUpperCase).forEach(System.out::println);

空流
Stream<String> emptyStream=Stream.empty();
```

由数组创建流

```
        int[] numbers = {2,3,5,7,11,14};
        int sum = Arrays.stream(numbers).sum();
```

由文件生成流



由函数生成流：创建无限流

```
        Stream.iterate(0, n-> n+2)
              .limit(10)
              .forEach(System.out::println);
```

```
        Stream.generate(Math::random)
              .limit(5)
              .forEach(System.out::println);
```

#### 中间操作

切片与筛选

filter：过滤流中的某些元素

```
List<Dish> vegetarianDishes = menu.stream()
    .filter(Dish::isVegetarian)
    .collect(Collectors.toList());
```

limit(n)：获取n个元素

```
List<Dish> limitDishes = menu.stream()
    .filter(d -> d.getCalories() > 300)
    .limit(3)
    .collect(Collectors.toList());
```

skip(n)：跳过n元素，配合limit(n)可实现分页

```
List<String> skipDishes = menu.stream()
    .map(Dish::getName)
    .skip(1)
    .collect(Collectors.toList());
```

distinct：通过流中元素的 hashCode() 和 equals() 去除重复元素

```
List<Dish> distinctDishes = menu.stream()
    .filter(Dish::isVegetarian)
    .distinct()
    .collect(Collectors.toList());
```

映射

map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。

```
List<String> mapDishes = menu.stream()
    .map(Dish::getName)
    .collect(Collectors.toList());
```

flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。

```
String[] words = new String[]{"Hello","World"};
List<String> flatMapWords = Arrays.stream(words)
    .map(word -> word.split(""))
    .flatMap(Arrays::stream)
    .distinct()
    .collect(Collectors.toList());
```

消费

peek：如同于map，能得到流中的每一个元素。但map接收的是一个Function表达式，有返回值；而peek接收的是Consumer表达式，没有返回值。

排序

sorted()：自然排序，流中元素需实现Comparable接口

sorted(Comparator com)：定制排序，自定义Comparator排序器

#### 终端操作

匹配

booelan allMatch(Predicate) 都符合

```
boolean isAllMatch = menu.stream()
	.allMatch(d -> d.getCalories() < 1000);
```

boolean anyMatch(Predicate) 任一元素符合

```
boolean isAnyMatch = menu.stream()
	.anyMatch(d -> d.getCalories() >= 1000);
```

boolean noneMatch(Predicate) 都不符合

```
boolean isNoneMatch = menu.stream()
	.noneMatch(d -> d.getCalories() >= 1000);
```

查找

findFirst——返回第一个元素

```
menu.stream()
        .filter(Dish::isVegetarian)
        .findFirst()
        .ifPresent(d -> System.out.println(d.getName()));
```

findAny——返回当前流中的任意元素

```
menu.stream()
        .filter(Dish::isVegetarian)
        .findAny()
        .ifPresent(d -> System.out.println(d.getName()));
```

计算和极值

count：返回流中元素的总个数

```
long count = menu.stream().map(x -> x.name).distinct().count();
```

规约

reduce()

元素求和

```
List<Integer> numbers = Arrays.asList(1,8,5,5);
int sum = numbers.stream().reduce(0, Integer::sum);
```

最大值和最小值

max：返回流中元素最大值

```
Optional<Integer> max = numbers.stream().reduce(Integer::max);
```

min：返回流中元素最小值

```
Optional<Integer> min = numbers.stream().reduce(Integer::min);
```

收集

collect：接收一个Collector实例，将流中元素收集成另外一个数据结构。
　　Collector<T, A, R> 是一个接口，有以下5个抽象方法：
　　Supplier<A> supplier()：创建一个结果容器A
　　BiConsumer<A, T> accumulator()：消费型接口，第一个参数为容器A，第二个参数为流中元素T。
　　BinaryOperator<A> combiner()：函数接口，该参数的作用跟上一个方法(reduce)中的combiner参数一样，将并行流中各 个子进程的运行结果(accumulator函数操作后的容器A)进行合并。
　　Function<A, R> finisher()：函数式接口，参数为：容器A，返回类型为：collect方法最终想要的结果R。
　　Set<Characteristics> characteristics()：返回一个不可变的Set集合，用来表明该Collector的特征。有以下三个特征：
　　CONCURRENT：表示此收集器支持并发。（官方文档还有其他描述，暂时没去探索，故不作过多翻译）
　　UNORDERED：表示该收集操作不会保留流中元素原有的顺序。
　　IDENTITY_FINISH：表示finisher参数只是标识而已，可忽略。



```
List<Transaction> transactions = transactionStream.collect(Collectors.toList());
```

查找流中的最大值和最小值

```
Comparator<Dish> dishCaloriesComparator = Comparator.comparingInt(Dish::getCalories);
Optional<Dish> mostCalorieDish = menu.stream()
     .collect(Collectors.maxBy(dishCaloriesComparator)); 
```

计数、求和、最大最小值、平均值

```
int totalCalories = menu.stream().collect(Collectors.summingInt(Dish::getCalories));

IntSummaryStatistics{count=10, sum=4850, min=120, average=485.000000, max=800}
```

连接字符串

```
String shortMenu = menu.stream().map(Dish::getName).collect(Collectors.joining(", "));
```

分组

```
Map<Dish.Type, List<Dish>> dishesByType =
        menu.stream().collect(Collectors.groupingBy(Dish::getType));
```

分区



#### 练习

```
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Transaction {
    private Trader trader;
    private int year;
    private int value;
}
```

```
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Trader {
    private String name;
    private String city;
}
```

```
public class Practice {
    public static void main(String[] args) {
        Trader raoul = new Trader("Raoul", "Cambridge");
        Trader mario = new Trader("Mario", "Milan");
        Trader alan = new Trader("Alan", "Cambridge");
        Trader brian = new Trader("Brian", "Cambridge");

        List<Transaction> transactions = Arrays.asList(
                new Transaction(brian, 2011, 300),
                new Transaction(raoul, 2012, 1000),
                new Transaction(raoul, 2011, 400),
                new Transaction(mario, 2012, 710),
                new Transaction(mario, 2012, 700),
                new Transaction(alan, 2012, 950)
        );

        // 找出2011年发生的所有交易，并按交易额排序（从低到高）。
        List<Transaction> tr2011 = transactions.stream()
                .filter(x -> x.getYear() == 2011)
                .sorted(Comparator.comparing(Transaction::getValue))
                .collect(Collectors.toList());

        // 交易员都在哪些不同的城市工作过
        List<String> cityNames = transactions.stream()
                .map(Transaction::getTrader)
                .map(Trader::getCity)
                .distinct()
                .collect(Collectors.toList());
        System.out.println(cityNames);
        List<String> citiesNames =
                transactions.stream()
                        .map(transaction -> transaction.getTrader().getCity())
                        .distinct()
                        .collect(Collectors.toList());
        System.out.println(citiesNames);
        Set<String> citiesNameSet  =
                transactions.stream()
                        .map(transaction -> transaction.getTrader().getCity())
                        .collect(Collectors.toSet());
        System.out.println(citiesNameSet);

        // 查找所有来自于剑桥的交易员，并按姓名排序
        List<Trader> cambridgeTrader = transactions.stream()
                .map(Transaction::getTrader)
                .filter(transaction -> transaction.getCity().equals("Cambridge"))
                .distinct()
                .sorted(Comparator.comparing(Trader::getName))
                .collect(Collectors.toList());
        System.out.println(cambridgeTrader);

        // 返回所有交易员的姓名字符串，按字母顺序排序
        List<String> traderNames = transactions.stream()
                .map(t -> t.getTrader().getName())
                .distinct()
                .sorted()
                .collect(Collectors.toList());
        System.out.println(traderNames);
        String traderStr =
                transactions.stream()
                        .map(transaction -> transaction.getTrader().getName())
                        .distinct()
                        .sorted()
                        .reduce("", (n1, n2) -> n1 + n2 + " ");
        System.out.println(traderStr);
        String traderStr1 =
                transactions.stream()
                        .map(transaction -> transaction.getTrader().getName())
                        .distinct()
                        .sorted()
                        .collect(Collectors.joining(" "));
        System.out.println(traderStr1);

        // 有没有交易员是在米兰工作的
        boolean isWorkMilan = transactions.stream()
                .anyMatch(a -> "Milan".equals(a.getTrader().getCity()));
        System.out.println(isWorkMilan);

        // 打印生活在剑桥的交易员的所有交易额
        List<Integer> liveCambridgeTrader = transactions.stream()
                .filter(transaction -> "Cambridge".equals(transaction.getTrader().getCity()))
                .map(Transaction::getValue)
                .collect(Collectors.toList());
        System.out.println(liveCambridgeTrader);

        // 所有交易中，最高的交易额是多少
        Optional<Integer> max = transactions.stream()
                .map(Transaction::getValue)
                .reduce(Integer::max);
        System.out.println(max.get());

        // 所有交易中，最小的交易额是多少
        Optional<Integer> min = transactions.stream()
                .map(Transaction::getValue)
                .reduce(Integer::min);
        System.out.println(min.get());

        // 找到交易额最小的交易
        Optional<Transaction> smallestTransaction =
                transactions.stream()
                        .min(Comparator.comparing(Transaction::getValue));
        System.out.println(smallestTransaction);
    }
}
```



### Optional

创建

声明一个空的Optional

```
        Optional<Car> optCar=Optional.empty();
```

依据一个非空值创建Optional

```
        Optional<Car> optCar=Optional.of(car);
```

可接受null的Optional

```
        Optional<Car> optCar=Optional.ofNullable(car);
```



### LocalDate和LocalTime

> https://blog.csdn.net/qq_43842093/article/details/127200353
>
> 
>
> https://blog.csdn.net/ArnoBM/article/details/119483903



### Ordering排序

### 字符串排序

```
public class OrderingTest {
    public static void main(String[] args) {
        List<String> list = Lists.newArrayList();
        list.add("apple");
        list.add("hurry");
        list.add("banana");
        list.add("banner");
        list.add("fdsfg");

        //natural()：使用Comparable类型的自然顺序， 例如：整数从小到大，字符串是按字典顺序;
        Ordering<String> orderingByNatural = Ordering.natural();
        //reverse(): 返回与当前Ordering相反的排序:
        Ordering<String> orderingByReverse = Ordering.natural().reverse();
        //　usingToString() ：使用toString()返回的字符串按字典顺序进行排序；
        Ordering<Object> orderingByUsingToStr = Ordering.usingToString();
        //　arbitrary() ：返回一个所有对象的任意顺序，
        Ordering<Object> orderingByarbitrary = Ordering.arbitrary();

        System.out.println("natural:" + orderingByNatural.sortedCopy(list));
        System.out.println("natural Reverse :" + orderingByReverse.sortedCopy(list));
        System.out.println("orderingByUsingToStr:" + orderingByUsingToStr.sortedCopy(list));
        System.out.println("arbitraryOrdering:" + orderingByarbitrary.sortedCopy(list));
        OrderingTest_NULL();
    }

    public static void OrderingTest_NULL() {
        List<String> list = Lists.newArrayList();

        list.add("apple");
        list.add("hurry");
        list.add("banana");
        list.add("banner");
        list.add(null);

        //返回一个将null放在non-null元素之前的Ordering，其他的和原始的Ordering一样；
        Ordering<String> orderingByNatural = Ordering.natural().nullsFirst();
        //返回一个将null放在non-null元素之后的Ordering，其他的和原始的Ordering一样；
        Ordering<Object> orderingByUsingToStr = Ordering.usingToString().nullsLast();

        System.out.println("natural:" + orderingByNatural.sortedCopy(list));
        System.out.println("orderingByUsingToStr:" + orderingByUsingToStr.sortedCopy(list));
    }
}
```

对象排序



## 《SQL 进阶教程》

### CASE表达式

#### 思考

```
select
	IFNULL(sum( CASE WHEN status = '1' THEN 1 ELSE 0 END ),0) AS payNum,
	IFNULL(sum( CASE WHEN status = '4' and scene in ('MALL', 'CATERING') THEN 1 ELSE 0 END ),0) AS shipNum,
	IFNULL(sum( CASE WHEN status = '3' and scene in ('SCENIC' ,'HOTEL') THEN 1 ELSE 0 END ),0) AS useNum
from
    general_order
```

#### 注意事项

- 统一各分支返回的数据类型
- 不要忘了写END
- 养成写ELSE子句的习惯

#### 1、已有编号方式转换为新的方式并统计

- 减少行数（行维度）

```
	SELECT  
    	CASE 
    		pref_name
                WHEN '德岛' THEN '四国’'
                WHEN '香川' THEN '四国'
                WHEN '爱媛' THEN '四国'
                WHEN '高知' THEN '四国'
                WHEN '福冈' THEN '九州'
                WHEN '佐贺' THEN '九州'
                WHEN '长崎' THEN '九州'
            ELSE '其他' END AS district,
            SUM(population) as population
      FROM  PopTbl
      GROUP BY district
```

#### 2、一条SQL语句进行不同条件的统计

- “行结构”换成了“列结构”
- 新手用WHERE子句进行条件分支，高手用SELECT子句进行条件分支。

```
    SELECT pref_name,
          --男性人口
          SUM( CASE WHEN sex ='1'THEN population ELSE 0 END) AS cnt_m,
          --女性人口
          SUM( CASE WHEN sex ='2'THEN population ELSE 0 END) AS cnt_f
      FROM  PopTbl2
     GROUP BY pref_name;
```

#### 3、UPDATE语句里进行条件分支

- 避免重复执行update

```
--用CASE表达式写正确的更新操作
UPDATE Salaries 
	SET salary =
CASE
		WHEN salary >= 300000 THEN salary ＊ 0.9 
		WHEN salary >= 250000 AND salary < 280000 THEN salary ＊ 1.2 
		ELSE salary END;

else salary end 必须加上，如果不加，条件1和条件2不满足会导致salary会被更新成null

UPDATE general_order 
	SET channel_source =
CASE
		WHEN channel_source = 'gg' THEN 'GRJY'
		ELSE channel_source END;
```

#### 4、表之间的数据匹配

- 1：n表转竖表

```
   --表的匹配：使用IN谓词
    SELECT course_name,
          CASE WHEN course_id IN
                        (SELECT course_id FROM OpenCourses
                          WHERE month = 200706) THEN '○'
                ELSE'×'END AS "6月",
          CASE WHEN course_id IN
                        (SELECT course_id FROM OpenCourses
                          WHERE month = 200707) THEN '○'
                ELSE'×'END AS "7月",
          CASE WHEN course_id IN
                        (SELECT course_id FROM OpenCourses
                          WHERE month = 200708) THEN '○'
                ELSE'×'END  AS "8月"
      FROM CourseMaster;


    --表的匹配：使用EXISTS谓词
    SELECT CM.course_name,
          CASE WHEN EXISTS
                        (SELECT course_id FROM OpenCourses OC
                          WHERE month = 200706

                              AND OC.course_id = CM.course_id) THEN'○'
                  ELSE'×'END AS "6月",
              CASE WHEN EXISTS
                          (SELECT course_id FROM OpenCourses OC
                            WHERE month = 200707
                              AND OC.course_id = CM.course_id) THEN'○'
                  ELSE'×'END AS "7月",
              CASE WHEN EXISTS
                          (SELECT course_id FROM OpenCourses OC
                            WHERE month = 200708
                              AND OC.course_id = CM.course_id) THEN'○'
                  ELSE'×'END  AS "8月"
        FROM CourseMaster CM;
```

#### 5、CASE表达式中使用聚合函数

- 新手用HAVING子句进行条件分支，高手用SELECT子句进行条件分支。

```
select
    scene,
    sum( CASE WHEN STATUS = '1' THEN 1 ELSE 0 END ) AS payNum,
    sum( CASE WHEN STATUS = '3' THEN 1 ELSE 0 END ) AS useNum,
    sum( CASE WHEN STATUS = '4' THEN 1 ELSE 0 END ) AS shipNum,
    COUNT( order_id ) AS orderNum
from
	general_order
```

#### 6、自定义排序方式

- order by

```
SELECT `key`
  FROM Greatests
 ORDER BY CASE `key`
            WHEN 'B' THEN 1
            WHEN 'A' THEN 2
            WHEN 'D' THEN 3
            WHEN 'C' THEN 4
            ELSE NULL END;

SELECT `key`,
       CASE `key`
         WHEN 'B' THEN '1'
         WHEN 'A' THEN '2'
         WHEN 'D' THEN '3'
         WHEN 'C' THEN '4'
         ELSE NULL END AS sort_col
FROM Greatests
ORDER BY sort_col;
```

### 自连接（self join）

相同的表进行的连接

#### 思考

**与多表之间进行的普通连接相比，自连接的性能开销更大**（特别是与非等值连接结合使用的时候），因此用于自连接的列推荐使用主键或者在相关列上建立索引

#### 排列、组合

- 有序对：<1, 2>≠<2, 1>
- 无序对：{1, 2}＝{2, 1}

```
有序对
SELECT
	P1.NAME AS name_1,
	P2.NAME AS name_2
FROM
	Products P1,
	Products P2 
WHERE
	P1.NAME <> P2.NAME

香蕉	苹果
橘子	苹果
香蕉	橘子
苹果	橘子
橘子	香蕉
苹果	香蕉
```

#### 删除重复行

集合是SQL能处理的唯一的数据结构

```
    --用于删除重复行的SQL语句(2)：使用非等值连接
    DELETE FROM Products P1
     WHERE EXISTS ( SELECT *
                      FROM Products P2
                    WHERE P1.name = P2.name
                      AND P1.price = P2.price
                      AND P1.rowid < P2.rowid );
```

#### 查找局部不一致的列

```
    --用于查找是同一家人但住址却不同的记录的SQL语句
    SELECT DISTINCT A1.name, A1.address
      FROM Addresses A1, Addresses A2
     WHERE A1.family_id = A2.family_id
      AND A1.address <> A2.address ;
      
    --用于查找价格相等但商品名称不同的记录的SQL语句
    SELECT DISTINCT P1.name, P1.price
      FROM Products P1, Products P2
     WHERE P1.price = P2.price
      AND P1.name <> P2.name;
```

#### 排序

Sql 四大排名函数（ROW_NUMBER、RANK、DENSE_RANK、NTILE）

> https://www.cnblogs.com/shizhijie/p/9366247.html

```
SELECT NAME,price,
	RANK() OVER ( ORDER BY price DESC ) AS rank_1,
	DENSE_RANK() OVER ( ORDER BY price DESC ) AS rank_2 
FROM
	Products;
```

```
    --排序从1开始。如果已出现相同位次，则跳过之后的位次
    SELECT P1.name,
          P1.price,
          (SELECT COUNT(P2.price)
              FROM Products P2
            WHERE P2.price > P1.price) + 1 AS rank_1
      FROM Products P1
      ORDER BY rank_1;
```

### 三值逻辑和NULL

#### 两种NULL

- 未知”（unknown）
- 不适用”（not applicable,inapplicable）

未知：不知道一个人什么时候死

不适用：不知道一个人死不死（因为人终有一死）

#### NULL值总结

> https://blog.csdn.net/ljl890705/article/details/97263432

- 1．NULL既不是值也不是变量。NULL只是一个表示“没有值”的标记
- 2．因为NULL不是值，所以不能对其使用谓词（比较谓词只适用于值）。
- 3．对NULL使用谓词后的结果是unknown。
- 4．unknown参与到逻辑运算时，SQL的运行会和预想的不一样。
- 最佳方法应该是往表里添加NOT NULL约束来尽力排除NULL

### HAVING子句

> https://blog.csdn.net/csucsgoat/article/details/115380747

#### HAVING与WHERE的区别

- WHERE是在GROUP BY分组之前进行条件筛选，后面不可以跟聚合函数。

- HAVING是在GROUP BY分组之后进行条件筛选，后面可以直接跟聚合函数。

#### 求众数

```
    --求众数的SQL语句(1)：使用谓词
    SELECT income, COUNT(＊) AS cnt
      FROM Graduates
     GROUP BY income
    HAVING COUNT(＊) >= ALL ( SELECT COUNT(＊)
                              FROM Graduates
                              GROUP BY income);
                              
--求众数的SQL语句(2)：使用极值函数
    SELECT income, COUNT(＊) AS cnt
      FROM Graduates
     GROUP BY income
    HAVING COUNT(＊) >=  ( SELECT MAX(cnt)
                            FROM ( SELECT COUNT(＊) AS cnt
                                    FROM Graduates
                                  GROUP BY income) TMP ) ;
```

#### 查询不包含NULL的集合

```
    --查询“提交日期”列内不包含NULL的学院(1)：使用COUNT函数
    SELECT dpt
      FROM Students
     GROUP BY dpt
    HAVING COUNT(＊) = COUNT(sbmt_date);
    
 --查询“提交日期”列内不包含NULL的学院(2)：使用CASE表达式
    SELECT dpt
      FROM Students
     GROUP BY dpt
    HAVING COUNT(＊) = SUM(CASE WHEN sbmt_date IS NOT NULL
                              THEN 1
                              ELSE 0 END);
```

### 外连接 

- 左外连接（LEFT OUTER JOIN）
- 右外连接（RIGHT OUTER JOIN）
- 全外连接（FULL OUTER JOIN）——相当于求集合的和

### 关联子查询比较行与行

- 代码的可读性不好
- 性能不好

### SQL进行集合运算

- SQL能操作具有重复行的集合，可以通过可选项ALL来支持
- 集合运算符有优先级







### 关系数据库的世界

#### 关系数据库的历史

关系模型的创始人E.F.Codd（1923—2003）关系数据库之父

- 1969年《大型数据库中关系存储的可推导性、冗余与一致性》
- 1970年《大型共享数据库的关系模型》
  - 定义了关系运算（relational calculus）
  - 定义了关系代数（relational algebra）
  - 采用谓词逻辑作为数据库操作的基础

Codd最具决定性的重要思想就是把数据看成关系的集合，然后再把关系看成（真）命题的集合。

> https://blog.sciencenet.cn/home.php?mod=space&uid=287179&do=blog&id=883429

#### 为什么叫“关系”模型

关系和表的比较

- 关系中不允许存在重复的元组（tuple），而表中可以存在。即，关系是通常说的不允许存在重复元素的集合，而表是多重集合（multiset）
- 关系中的元组没有从上往下的顺序，而表中的行有从上往下的顺序
- 关系中的属性没有从左往右的顺序，而表中的列有从左往右的顺序
- 关系中所有的属性的值都是不可分割的，而表中列的值是可以分割的。换句话说，关系中的属性满足第一范式，而表中的列不满足第一范式

#### 开始于关系，结束于关系

追求理论的严谨，并不会降低它的实用性。相反，越严谨越优雅的理论越实用。

Theory is practical.

#### 地址这一巨大的怪物

关系数据库中不存在编程语言中一般被称为“指针”的物理性数据结构。但是严格来说，它其实是存在的，只不过被隐藏了，因而对用户不可见。



精巧的数据结构搭配笨拙的代码，远远好过笨拙的数据结构搭配精巧的代码。

#### 从面向过程思维向声明式思维、面向集合思维转变

- 用CASE表达式代替IF语句和CASE语句

- 用GROUP BY和关联子查询代替循环
- 表中的行没有顺序
- 将表看成集合
- 理解EXISTS谓词和“量化”的概念
- 学习HAVING子句的真正价值
- 不要画长方形，去画圆

#### 消灭NULL委员会

“没有油箱的车”和“空油箱”是不同的

- 数值：用0代替
- 日期：用最大值或最小值代替



























































SELECT-使用条件逻辑

```
select 
	order_id,charge,
case 
	when charge <= 33 then '不值钱'
	when charge >= 333 then '有点小贵'
	else '问题不大'
end as status
from `general_order`
```

SELECT-随机返回若干行记录

```
select 
	order_id,charge,
case 
	when charge <= 33 then '不值钱'
	when charge >= 333 then '有点小贵'
	else '问题不大'
end as status
from `general_order`
order by RAND() limit 5
```

SELECT-查找列为Null值

```
select 
	order_id,charge
from `general_order`
WHERE charge is null
```

SELECT-查找Null值转换为实际值

```
select 
	order_id, COALESCE(charge,'0.00')  as charge
from `general_order`

select 
	order_id,
case 
	when charge is null then '0.00'
	else charge
end as charge
from `general_order`
```



## 《MySQL DBA修炼之道》

### 开发技巧

#### 1、存储树形数据

- 路径枚举

增加一个字段path，用于记录节点的所有祖先信息。

优：扩展性更好，更能适应未来数据的不断增长

缺：冗余存储了一些数据

- 闭包表

额外增加一张表，用于记录节点之间的关系。它不仅记录了节点之间的父子关系，也记录了树中所有节点之间的关系

优：增加一张表，以空间换时间；节点关系更容易维护

> https://blog.csdn.net/Trista_1999/article/details/109100795

#### 2、处理NULL值

```
NULL处理，可使用IS NULL和IS NOT NULL操作符

COUNT（*）包含null， COUNT（字段名）不包含null

尽量避免使用NULL值
```

- 使用CASE语句

```
select 
	case when price is null then 0 else price end
from 
	tb_commidity
```

- 使用IFNULL函数

```
select 
	ifnull(price, 0)
from 
	tb_commidity
```

- 使用IF函数

```
select 
	if(price is null,0,price)
from 
	tb_commidity
```

- 使用COALESCE函数

```
select 
	coalesce(price,0)
from 
	tb_commidity
```

## 《MySQL是怎样运行的》

### MySQL安装配置

#### 服务器处理客户端请求流程

- 连接管理
- 解析与优化
  - 查询缓存
  - 语法解析
  - 查询优化
- 存储引擎

#### 配置文件生效优先级

- 如果我们在多个配置文件中设置了相同的启动选项，那以最后一个配置文件中的为准
- 同一个配置文件中多个组的优先级，将以最后一个出现的组中的启动选项为准
- 如果同一个启动选项既出现在命令行中，又出现在配置文件中，那么以命令行中的启 动选项为准！

### 字符集和比较规则

每种字符集对应若干种比较规则，每种字符集都有一种默认的比较规则

- 字符集：字符和二进制的映射规则
- 比较规则：两个字符如何比较

常见字符集

- ASCII 字符集
- GBK 字符集
- utf8 字符集

#### MySQL中utf8和utf8mb4的区别

- utf8mb3（utf8） ：阉割过的 utf8 字符集，只使用1～3个字节表示字符。 
- utf8mb4 ：正宗的 utf8 字符集，使用1～4个字节表示字符。

#### 字符集的查看

```
 SHOW CHARSET;
```

#### 比较规则的查看

```
SHOW COLLATION;
```

#### 级别

- 服务器级别 

```
SHOW VARIABLES LIKE 'character_set_server';  // utf8
SHOW VARIABLES LIKE 'collation_server';		// utf8_general_ci
```

- 数据库级别 

```
SHOW VARIABLES LIKE 'character_set_database';	// utf8
SHOW VARIABLES LIKE 'collation_database';		// utf8_general_ci
```

- 表级别 

如果创建和修改表的语句中没有指明字符集和比较规则，将使用该表所在数据库的字符集和比较规则作为该表的字符集和比较规则

- 列级别

如果在创建和修改的语句中没有指明字符集和比较规则，将使用该列所在表的字符集和比较规 则作为该列的字符集和比较规则

**只修改字符集，则比较规则将变为修改后的字符集默认的比较规则。** 

**只修改比较规则，则字符集将变为修改后的比较规则对应的字符集**

#### 客户端和服务器通信中的字符集

- character_set_client 
- character_set_connection
-  character_set_results 

```
// 命令执行
SET NAMES utf8;

// 配置文件配置
[client]
default-character-set=utf8
```

### InnoDB记录结构

#### 简介

数据处理在内存中、而数据存储在磁盘中

InnoDB：将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小 一般为 16 KB。

#### 行格式

记录在磁盘上的存放方式

```
# 指定行格式语法
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

分类

- COMPACT行格式（紧密的）
- Redundant行格式（冗余的）
- Dynamic行格式（动态的）
- Compressed行格式（压缩的）

#### COMPACT行格式





#### 行溢出

 一个页一般是 16KB ，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，在当前页**记录的真实数据**处用20个字节存储指向这些页的地址。这种现象称为行溢出 。

### InnoDB数据页结构

页的大小16KB ，不同部分有不同的功能

| 名称               | 中文名             | 占用空间大小 | 简单描述                 |
| ------------------ | ------------------ | ------------ | ------------------------ |
| File Header        | 文件头部           | 38 字节      | 页的一些通用信息         |
| Page Header        | 页面头部           | 56 字节      | 数据页专有的一些信息     |
| Infimum + Supremum | 最小记录和最大记录 | 26 字节      | 两个虚拟的行记录         |
| User Records       | 用户记录           | 不确定       | 实际存储的行记录内容     |
| Free Space         | 空闲空间           | 不确定       | 页中尚未使用的空间       |
| Page Directory     | 页面目录           | 不确定       | 页中的某些记录的相对位置 |
| File Trailer       | 文件尾部           | 8 字节       | 校验页是否完整           |



每个数据页的 File Header 部分都有上一个和下一个页的编号，所以所有的数据页会组成一个 双链表 。

不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个 节点是按照主键值由小到大的顺序连接起来的







### B+树索引



#### MySQL中创建和删除索引的语句

创建

```
CREATE TALBE 表名 ( 
	各种列的信息 ··· , 
	[KEY|INDEX] 索引名 (需要被索引的单个列或多个列) 
)
```

修改

```
ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);
```

删除

```
ALTER TABLE 表名 DROP [INDEX|KEY] 索引名
```

#### 索引的代价

- 空间上的代价

一个索引对应一个B+树，一个B+数至少有一个数据页（16KB），需要额外的存储空间

- 时间上的代价

对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。需要额外的时间。

#### B+树索引适用的条件

```
CREATE TABLE person_info(
	id INT NOT NULL auto_increment,
	name VARCHAR(100) NOT NULL,
	birthday DATE NOT NULL,
	phone_number CHAR(11) NOT NULL,
	country varchar(100) NOT NULL,
	PRIMARY KEY (id),
	KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

##### 全值匹配

**搜索条件中的列和索引列一致**

```
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
```

- 先按照name列的值进行排序
- 再按照birthday列的值进行排序
- 再按照phone_number列的值进行排序

WHERE 子句中的几个搜索条件的顺序对查询结果没有啥影响。MySQL 有一个叫查询优化器的东东，会分析这些搜索条件并且按照可以使用的索引中列的顺 序来决定先使用哪个搜索条件，后使用哪个搜索条件。

##### 匹配左边的列

如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中 从最左边连续的列。

```
# 生效
SELECT * FROM person_info WHERE name = 'Ashburn'; 

# 生效
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';

# 失效
SELECT * FROM person_info WHERE birthday = '1990-09-27';

# name生效，phone_number失效
SELECT * FROM person_info WHERE name = 'Ashburn' AND phone_number = '15123983239';
```

##### 匹配列前缀

- 先按照字符串的第一个字符进行排序。 
- 如果第一个字符相同再按照第二个字符进行排序。 
- 如果第二个字符相同再按照第三个字符进行排序，依此类推。

```
# 生效
SELECT * FROM person_info WHERE name LIKE 'As%';

# 失效
SELECT * FROM person_info WHERE name LIKE '%As%';
```

##### 匹配范围值

```
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

- 找到 name 值为 Asa 的记录。 
- 找到 name 值为 Barlow 的记录。 
- 哦啦，由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记 录都可以很容易的取出来喽～ 
- 找到这些记录的主键值，再到 聚簇索引 中 回表 查找完整的记录。

```
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-0
1';
```

如果对多个列同时进行范围查找的话，只有对索引最左边的那个 列进行范围查找的时候才能用到 B+ 树索引

##### 精确匹配某一列并范围匹配另外一列

```
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday
< '2000-12-31' AND phone_number > '15100000000';
```

-  name = 'Ashburn' ，对 name 列进行精确查找，当然可以使用 B+ 树索引了。 
- birthday > '1980-01-01' AND birthday < '2000-12-31' ，由于 name 列是精确查找，所以通过 name = 'Ashburn' 条件查找后得到的结果的 name 值都是相同的，它们会再按照 birthday 的值进行排序。所以此时 对 birthday 列进行范围查找是可以用到 B+ 树索引的。 
- phone_number > '15100000000' ，通过 birthday 的范围查找的记录的 birthday 的值可能不同，所以这个 条件无法再利用 B+ 树索引了，只能遍历上一步查询得到的记录。

##### 用于排序

```
SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;

直接从索引中提取数据，然后进行回表操作取出该索引中不包含的列就好了
```

- 先按照 name 值排序，
- 如果记录的 name 值相同，则需要按照 birthday 来排序，
- 如果 birthday 的值相同，则需要按照 phone_number 排序

不生效情况

- ASC、DESC混用

- WHERE子句中出现非排序使用到的索引列
- 排序列包含非同一个索引的列
- 排序列使用了复杂的表达式

##### 用于分组

```
SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, ph
one_number
```

分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边 的列进行分组

####  回表的代价

覆盖索引

```
最好在查询列表里只包含索引列
SELECT 
	name, birthday, phone_number 
FROM 
	person_info 
WHERE
	name > 'Asa' AND name < 'Barlow'
```

#### 如何挑选索引

- 只为用于搜索、排序或分组的列创建索引

只为出现在 WHERE 子句中的列、连接子句中的连接列，或者出现在 ORDER BY 或 GROUP BY 子句中的 列创建索引

- 考虑列的基数

列的基数 指的是某一列中不重复数据的个数

最好为那些列的基数大的列建立索引，为基数 太小列的建立索引效果可能不好。

- 索引列的类型尽量小

数据类型越小，在查询时进行的比较操作越快（这是CPU层次的东东） 

数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带 来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

- 索引字符串值的前缀	
- 让索引列在比较表达式中单独出现

如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。

- 主键插入顺序

让主键具 有 AUTO_INCREMENT ，让存储引擎自己为表生成主键，而不是我们手动插入

- 冗余和重复索引

避免重复创建索引

### 数据目录

#### 数据目录和安装目录的区别

MySQL 的安装目录——在安装 MySQL 的时候我们可以自己指定

MySQL 的数据目录——用来存储 MySQL 在运行过程中产生的数据

查看数据目录路径

```
SHOW VARIABLES LIKE 'datadir';
```

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20230227_233132.jpg)

#### 数据目录的结构

- 数据库在文件系统中的表示

在数据目录下创建一个和数据库名同名文件夹

- 表在文件系统中的表示

InnoDB是如何存储表数据的

系统表空间：可以对应文件系统上一个或多个实际的文件

独立表空间:在MySQL5.6.6以及之后的版本中， InnoDB 并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表 建立一个独立表空间，也就是说我们创建了多少个表，就有多少个独立表空间。

#### 文件系统对数据库的影响

- 数据库名称和表名称不得超过文件系统所允许的最大长度
- 特殊字符的问题
- 文件长度受文件系统最大长度限制

#### MySQL系统数据库简介

系统数据库

- mysql 

这个数据库贼核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过 程中产生的日志信息，一些帮助信息以及时区信息等。 

- information_schema 

这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪 些列、哪些索引吧啦吧啦。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数 据。

- performance_schema 

这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。 包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。 

- sys 

这个数据库主要是通过视图的形式把 information_schema 和 performance_schema结合起来，让程序员可以 更方便的了解MySQL服务器的一些性能信息。

### InnoDB的表空间

#### 独立表空间



#### 系统表空间

### 单表访问方法

```
CREATE TABLE single_table (
 id INT NOT NULL AUTO_INCREMENT,
 key1 VARCHAR(100),
 key2 INT,
 key3 VARCHAR(100),
 key_part1 VARCHAR(100),
 key_part2 VARCHAR(100),
 key_part3 VARCHAR(100),
 common_field VARCHAR(100),
 PRIMARY KEY (id),
 KEY idx_key1 (key1),
 UNIQUE KEY idx_key2 (key2),
 KEY idx_key3 (key3),
 KEY idx_key_part(key_part1, key_part2, key_part3)
) Engine=InnoDB CHARSET=utf8;
```

#### 访问方法

不同的访问方法结果相同，但过程不同——条条大路通罗马

- 使用全表扫描进行查询
- 使用索引进行查询

#### const

直接通过主键聚簇索引定位对应的记录

```
SELECT * FROM single_table WHERE id = 1438;
```

#### ref

- 先通过索引查找记录对应的主键id的值（连续的记录）
- 再根据这些id回表查询完整用户记录

```
SELECT * FROM single_table WHERE key1 = 'abc';
```

#### ref_or_null

- 先通过索引查找key1 IS NULL 和 key1 = 'abc' 的两个连续的记录范围的id
- 再根据这些id回表查询完整用户记录

```
SELECT * FROM single_demo WHERE key1 = 'abc' OR key1 IS NULL;
```

#### range

```
SELECT * FROM single_table WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79);
```

#### index



#### all

直接扫描聚簇索引





#### 索引合并

##### Intersection合并

```
SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
```

- 从 idx_key1 二级索引对应的 B+ 树中取出 key1 = 'a' 的相关记录。 
- 从 idx_key3 二级索引对应的 B+ 树中取出 key3 = 'b' 的相关记录。 
- 二级索引的记录都是由 索引列 + 主键 构成的，所以我们可以计算出这两个结果集中 id 值的交集。 
- 按照上一步生成的 id 值列表进行回表操作，也就是从聚簇索引中把指定 id 值的完整用户记录取出来，返回 给用户。

情况一：二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能 出现只出现匹配部分列的情况。

```
SELECT * FROM single_table WHERE key1 = 'a' AND key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c';
```

情况二：主键列可以是范围匹配

```
 SELECT * FROM single_table WHERE id > 100 AND key1 = 'a';
```

##### Union合并

```
SELECT * FROM single_table WHERE key1 = 'a' OR key3 = 'b'
```



##### Sort-Union合并

```
SELECT * FROM single_table WHERE key1 < 'a' OR key3 > 'z'
```

- 先根据 key1 < 'a' 条件从 idx_key1 二级索引总获取记录，并按照记录的主键值进行排序 
- 再根据 key3 > 'z' 条件从 idx_key3 二级索引总获取记录，并按照记录的主键值进行排序 
- 因为上述的两个二级索引主键值都是排好序的，剩下的操作和 Union 索引合并方式就一样了。

### 两个表连接的原理

#### 连接的本质

是把各个连接表中的记录都取出来依次匹配的组合加入结果集并返回

#### 连接过程

驱动表（第一个需要查询的表）只需要访问一次，被驱动表（被连接的表）可能被访问多次

#### 自然连接

笛卡尔积

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20230228_152846.jpg)

#### 内连接

#### 左外连接

#### 右外连接



#### 连接的原理

##### 嵌套循环连接

驱动表只访问一次，但被驱动表却可能被多次访问，访问次数取决于对驱动表执行单表查询后的结果集中的记录条数

##### 使用索引加快连接速度



##### 基于块的嵌套循环连接



### MySQL基于成本的优化

#### MySQL执行的成本

- I/O 成本

 存储引擎都是将数据和索引都存储到磁盘上的，当我们想查询表中的 记录时，需要先把数据或者索引加载到内存中然后再操作。这个从磁盘到内存这个加载的过程损耗的时间称 之为 I/O 成本。

- CPU 成本

读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间称之为 CPU 成本。

#### 单表查询的成本

##### 基于成本的优化步骤

1. 根据搜索条件，找出所有可能使用的索引 
2. 计算全表扫描的代价
3. 计算使用不同索引执行查询的代价
4. 对比各种执行方案的代价，找出成本最低的那一个

##### 基于索引统计数据的成本计算



#### 连接查询的成本

Condition filtering

两表连接的成本分析

多表连接的成本分析



### InnoDB统计数据是如何收集的

#### 两种不同的统计数据存储方式

- 永久性的统计数据
- 非永久性的统计数据



### MySQL基于规则的优化

查询重写 （就是MySQL觉得你写的语句不好，自己再重写一遍）

#### 条件化简

移除不必要的括号

常量传递

等值传递

移除没用的条件

表达式计算

HAVING子句和WHERE子句的合并

常量表检测

#### 外连接消除

#### 子查询优化





### Explain详解

#### 执行计划输出中各列详解

##### table

##### id

在连接查询的执行计划中，每个表都会对应一条记录，这些记录的id列的值是相同的，出 现在前边的表表示驱动表，出现在后边的表表示被驱动表。

##### select_type



##### partitions

##### type

##### possible_keys和key

##### key_len

##### ref

##### rows

##### filtered

##### Extra

#### Json格式的执行计划

```
EXPLAIN FORMAT=JSON delete FROM addresses where name = '前田义明';
```

```
{
    "query_block":{
        "select_id":1,
        "table":{
            "delete":true,
            "table_name":"addresses",
            "access_type":"range",
            "possible_keys":[
                "PRIMARY"
            ],
            "key":"PRIMARY",
            "used_key_parts":[
                "name"
            ],
            "key_length":"130",
            "ref":[
                "const"
            ],
            "rows_examined_per_scan":1,
            "filtered":"100.00",
            "attached_condition":"(`xiao`.`addresses`.`name` = '前田义明')"
        }
    }
}
```





#### Extented EXPLAIN





### optimizer trace表



### InnoDB的Buffer





### 事务

原子性

隔离性

一致性

持久性



### redo日志



### undo日志





### 锁









MySQL 8 新特性





















































































> mysql中的回表操作
>
> https://blog.csdn.net/qq_53310540/article/details/125695927
>
> https://zhuanlan.zhihu.com/p/512662526

























































