





## 准备

### 思考

为什么考研？

想

考什么学校？

合工大

考什么专业？

计算机

全日制还是非全？

非全

![image-20220630213403815](C:\Users\xiao\AppData\Roaming\Typora\typora-user-images\image-20220630213403815.png)

![image-20220630213438188](C:\Users\xiao\AppData\Roaming\Typora\typora-user-images\image-20220630213438188.png)

![image-20220702131910411](C:\Users\xiao\AppData\Roaming\Typora\typora-user-images\image-20220702131910411.png)

![image-20220702131926784](C:\Users\xiao\AppData\Roaming\Typora\typora-user-images\image-20220702131926784.png)

《数据结构（C++描述）》，胡学钢、张晶，人民邮电出版社，2011 《软件工程导论》（第 6 版），张海藩、牟永敏，清华大学出版社，2013

### 买买买

#### 政治

- 徐涛背诵笔记
- 肖大爷1000题
- 肖四
- 肖八

7.1-8.1——背诵笔记

8.1-9.1——1000题

9.1-10.1——1000题

10.1-11.1——肖四

11.1-12.25——肖八

#### 英语

- 阅读理解一本
- 历年真题

7.1-12.25——单词一直背，注意方法

7.1-10.1——阅读理解

10.1-11.1——模拟试卷

11.1-12.25——英语二真题

#### 数学

- 张宇36讲
- 模拟卷
- 数学真题

7.1-10.1——36讲刷一遍

10.1-11.1——模拟试卷，36讲第二遍

11.1-12.25——数学真题

#### 专业课

- 王道
- 推荐书目

8.1-10.1——王道

10.1-11.1——推荐书籍

11.1-12.1——试卷刷题

### 时间表

![](F:\2023\images\xiao_20220703_100000.png)









#### 政治-77



#### 英语-75



数学-100



#### 专业课-111



# java基础

## 基础

###  版本

- Java SE（标准版）
- Java EE（企业版）
- Java ME（微缩版）

###  语言特点

- 面向对象(使用计算机模拟现实世界,解决现实题,贴近人类思维模式)
- 筒单(相对C、C+、C#,不易造成内存溢出、滅少代码量、代码可读性强)
- 跨平台(操作系统、服务器、数据库)
- 可靠性
- 安全性
- 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；
- 编译与解释并存

###  运行机制

.java源程序——编译器——.class字节码——解析器——机械码——计算机

### 环境搭建

- JDK（java development kit）
  开发环境，包含JRE+类库+开发工具包（编译器+调试工具）
- JRE（java runtime environment）
  运行环境，包含：JVM和解释器
- JVM（java virtual machine）
  不同的操作系统中，模拟相同的环境

## 语法

#### 语言基础

#####  变量

- 第一种声明方式——先声明后赋值
  数据类型   变量名;
  `Int age;//开辟整数変量空间`
  変量名=值
  `age=18;/将整数值赋给変量`
- 第二种声明方式——声明并赋值
  `int age = 18；`
- 第三种声明方式——多个同类型变量的声明并赋值
  `int x,y,z = 11,12,13;`
- 注意:Java是强类型语言,変量的类型必须与数据的类型一致。
- 声明一个变量后，必须用赋值语句对变量进行显式初始化

#####  常量

```
# 常量名一般使用大写字符
final 常量名=值;
final double PI=3.14; 
final String LOVE="imooc";
```

##### 运算符

###### 赋值运算符

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194703.png)

###### 算术运算符	

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194724.png)

###### 关系运算符

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194747.png)

###### 逻辑运算符	

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194804.png)

###### 位运算符

与（&）、非（~）、或（|）、异或（^）

###### 移位运算符

<<    :   左移运算符，num << 1,相当于num乘以2

\>>    :   右移运算符，num >> 1,相当于num除以2

\>>>   :   无符号右移，忽略符号位，空位都以0补齐

###### 三目运算符

格式
` 布尔表达式?结果1:结果2    //布尔表达式为真，则结果1，布尔表达式为假，则结果2` 

```
public static void main(String[] args) {
	int age = 18;
	String age1=age == 17?"成年了":"未成年";
	System.out.println(age1);
	int x = 10;
	int y = 5;
	int z;
	z = (x > y) ? x : y;//三目运算符
		/*if (x>y){
			z = x;
		}else {
			z = y;
		}*/
	System.out.println("z = " + z);
	}
}
```

###### 转义运算符

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211114_220021.png)

```
System.out.println("xx\tx\t");
System.out.println("y\nyy");
System.out.println("\\");
System.out.println("\"");
System.out.println("\'");
System.out.println("\rzzz");
```

##### 数据类型

![](https://java-md-note.oss-cn-hangzhou.aliyuncs.com/JavaMDNote/xiao20211017-194820.png)

###### 数据类型转换

- 自动类型转换

byte->short->char->int->long->float->double

- 强制类型转换

```
public class TypeConversion {
    public static void main(String[] args) {
        short s = 123;
        int i = s;        	// 目标类型大于源类型  自动类型转换 short ---> int
        System.out.println(i);

        double d = i;       // 目标类型大于源类型  自动类型转换 int ---> double
        System.out.println(d);

        short num = 123;
        byte target = (byte) num;       // 目标类型小于源类型  强制类型转换 short ---> byte
        System.out.println(target);

        double x = 12.34;
        int y = (int) x;            // 目标类型小于源类型  强制类型转换 double ---> int
        System.out.println(y);

        short m = 258;
        byte n = (byte) m;      // 目标类型小于源类型  强制类型转换 short ---> byte
        System.out.println(n);

        int a = -65;
        char b = (char) a;      // 目标类型小于源类型  强制类型转换 int ---> char
        System.out.println(b);
    }
}
```

- 字符串转为Int类型

```
public class StringChangeToInt {
    public static void main(String[] args) {
        // 方式一
        int num = Integer.parseInt("56544");
        // 方式二
        int num2=Integer.valueOf("123");
        System.out.println(num+"  "+num2);
    }
}
```

###### 包装类

Java提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：

| 基本类型 | 对应的包装类（位于java.lang包中） |
| -------- | --------------------------------- |
| byte     | Byte                              |
| short    | Short                             |
| int      | **Integer**                       |
| long     | Long                              |
| float    | Float                             |
| double   | Double                            |
| char     | **Character**                     |
| boolean  | Boolean                           |

###### Integer类

- Integer类概述

  包装一个对象中的原始类型 int 的值

- Integer类构造方法及静态方法

| 方法名                                  | 说明                                   |
| --------------------------------------- | -------------------------------------- |
| public Integer(int   value)             | 根据 int 值创建 Integer 对象(过时)     |
| public Integer(String s)                | 根据 String 值创建 Integer 对象(过时)  |
| public static Integer valueOf(int i)    | 返回表示指定的 int 值的 Integer   实例 |
| public static Integer valueOf(String s) | 返回保存指定String值的 Integer 对象    |

- 示例代码

```java
public class IntegerDemo {
    public static void main(String[] args) {
        //public Integer(int value)：根据 int 值创建 Integer 对象(过时)
        Integer i1 = new Integer(100);
        System.out.println(i1);

        //public Integer(String s)：根据 String 值创建 Integer 对象(过时)
        Integer i2 = new Integer("100");
		//Integer i2 = new Integer("abc"); //NumberFormatException
        System.out.println(i2);
        System.out.println("--------");

        //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例
        Integer i3 = Integer.valueOf(100);
        System.out.println(i3);

        //public static Integer valueOf(String s)：返回保存指定String值的Integer对象 
        Integer i4 = Integer.valueOf("100");
        System.out.println(i4);
    }
}
```

###### 装箱与拆箱

> https://www.cnblogs.com/dolphin0520/p/3780005.html

基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：

* **装箱**：从基本类型转换为对应的包装类对象。

* **拆箱**：从包装类对象转换为对应的基本类型。

用Integer与 int为例：

基本数值---->包装对象

~~~java
Integer i = new Integer(4);//使用构造函数函数
Integer iii = Integer.valueOf(4);//使用包装类中的valueOf方法
~~~

包装对象---->基本数值

~~~java
int num = i.intValue();
~~~

> https://www.cnblogs.com/dolphin0520/p/3780005.html

Integer 例子:

```java
  Integer i1 = 40;
  Integer i2 = 40;
  Integer i3 = 0;
  Integer i4 = new Integer(40);
  Integer i5 = new Integer(40);
  Integer i6 = new Integer(0);
  
  System.out.println("i1=i2   " + (i1 == i2));
  System.out.println("i1=i2+i3   " + (i1 == i2 + i3));
  System.out.println("i1=i4   " + (i1 == i4));
  System.out.println("i4=i5   " + (i4 == i5));
  System.out.println("i4=i5+i6   " + (i4 == i5 + i6));   
  System.out.println("40=i5+i6   " + (40 == i5 + i6));     
```

结果：

```
i1=i2   true
i1=i2+i3   true
i1=i4   false
i4=i5   false
i4=i5+i6   true
40=i5+i6   true
```

解释：

语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。

###### 自动装箱与自动拆箱

由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：

```java
Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);
i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;
//加法运算完成后，再次装箱，把基本数值转成对象。
```

###### 基本类型转换为String

- 转换方式

  * 方式一：直接在数字后加一个空字符串

   - 方式二：通过String类静态方法valueOf()

- 示例代码

```java
public class IntegerDemo {
    public static void main(String[] args) {
        //int --- String
        int number = 100;
        //方式1
        String s1 = number + "";
        System.out.println(s1);
        //方式2
        //public static String valueOf(int i)
        String s2 = String.valueOf(number);
        System.out.println(s2);
        System.out.println("--------");
    }
}
```

  ###### String转换成对应的基本类型 

除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：

- `public static byte parseByte(String s)`：将字符串参数转换为对应的byte基本类型。
- `public static short parseShort(String s)`：将字符串参数转换为对应的short基本类型。
- `public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。
- `public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。
- `public static float parseFloat(String s)`：将字符串参数转换为对应的float基本类型。
- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。
- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的boolean基本类型。

代码使用（仅以Integer类的静态方法parseXxx为例）如：

- 转换方式
  - 方式一：先将字符串数字转成Integer，再调用valueOf()方法
  - 方式二：通过Integer静态方法parseInt()进行转换
- 示例代码

```java
public class IntegerDemo {
    public static void main(String[] args) {
        //String --- int
        String s = "100";
        //方式1：String --- Integer --- int
        Integer i = Integer.valueOf(s);
        //public int intValue()
        int x = i.intValue();
        System.out.println(x);
        //方式2
        //public static int parseInt(String s)
        int y = Integer.parseInt(s);
        System.out.println(y);
    }
}
```

> 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。

#### 流程控制

##### 选择分支

###### if...else...语句

###### switch语句

```
import java.util.Scanner;

public class WeekdaySwitch{
	public static void main(String[] args){	
		//一周计划
		Scanner sc = new Scanner(System.in);
		System.out.println("请输入1-7的数字：");
		int weekDay = sc.nextInt();
		switch(weekDay){
			default:
				System.out.println("录入有误，请输入1~7之间的有效数字！");
				break;
			case 1:
				System.out.println("学习java");
				break;		
			case 2:
			case 5:
			case 6:
				System.out.println("玩游戏");
				break;		
			case 3:
				System.out.println("爬山");
				break;	
			case 4:
				System.out.println("上班");
				break;
			case 7:
				System.out.println("考试");
				break;			
		}	
		System.out.println("结束");		
	}
}
```

##### 循环

###### do...while循环

```
// do ... while循环
	public static void sum2() {
		int i = 0 ;
		int sum = 0;
		do{
			sum = sum + i;
			i++;
		}while(i<101);
		System.out.println(sum);
	}
```

###### while循环

```
// while循环
	public static void sum1() {
		int i = 0 ;
		int sum = 0;
		while(i<101){
			sum = sum + i;
			i++;
		}
		System.out.println(sum);
	}
```

###### for循环

```
// for循环
	public static void sum(){
		int sum = 0;
		for(int i=1;i<101;i++) {
			if(i%2!=0) {
			sum = sum + i;
			}
		}
		System.out.println(sum);
	}	
```

###### foreach 循环 (两个功能：1遍历数组 2 遍历集合）

```
public class ForEachCircular {
    public static void main(String[] args) {
        // foreach循环遍历数组
        String [] names = {"xiao","xian","hua","nian"};
        for(String name:names){
            System.out.print(name + "\t");
        }
        System.out.println();
        // foreach循环遍历集合
        ArrayList<String> ming = new ArrayList<String>();
        ming.add("xiao");
        ming.add("xian");
        ming.add("hua");
        ming.add("nian");
        for(String m:ming){
            System.out.print(m + "\t");
        }
    }
}
```

##### 跳转

###### break语句  :跳出循环

###### continue语句：跳出本次循环

```
public class BreakAndContinue {
    public static void main(String[] args) {
        for (int i = 1; i < 6 ; i++) {
            if (i % 5 ==0){
                break;
            }
            System.out.println("当前循环次数：" + i);
        }
        System.out.println("<--------------------->");
        for (int i = 1; i < 7 ; i++) {
            if (i % 5 ==0){
                continue;
            }
            System.out.println("当前循环次数：" + i);
        }
    }
}
```

####  java数组学习

##### 数组的定义

同一种类型数据的集合

```
    // 第一种  数组的定义  定义一个存储3个整数的容器
	int [] x = new int[3];
	// 第二种  数组的定义  定义一个存储3个整数的容器
	int [] y = new int[] {2,7,6,9,4,3,3};
	// 第三种  数组的定义  定义一个存储3个整数的容器
	int [] z = {2,7,6,9,4,3,3};

        // 数组定义，二维数组
	// 第一种  数组的定义  
		int [][] arr4 = new int[3][5];
	// 第二种  数组的定义  
		int [][] arr5 = new int[][] {{-2,7,6},{-9,4,3,3}};
	// 第三种  数组的定义  
		int [][] arr6= {{-2,7,6},{-9,4,3,3}};
```

##### 数组的操作

```
package base;

public class Array_learn {
public static void main(String[] args) {
	// 数组定义，一维数组
	// 第一种  数组的定义  定义一个存储3个整数的容器
	int [] arr1 = new int[3];
	// 第二种  数组的定义  
	int [] arr2 = new int[] {-2,7,6,-9,4,3,3};
	// 第三种  数组的定义  
	int [] arr3= {2,7,6,9,4,3,3};
	
	// 数组定义，二维数组
	// 第一种  数组的定义  
		int [][] arr4 = new int[3][5];
	// 第二种  数组的定义  
		int [][] arr5 = new int[][] {{-2,7,6},{-9,4,3,3}};
	// 第三种  数组的定义  
		int [][] arr6= {{-2,7,6},{-9,4,3,3}};
	
	// 打印数组
	printArray(arr2);
	//获取数组中的最大值
	int max = getArrayMax(arr2);
	System.out.println(max);
	//获取数组中的最小值
	int min = getArrayMin(arr2);
	System.out.println(min);
	// 数组的排序之冒泡排序
	bubbleSort(arr2);
	printArray(arr2);
	// 数组的排序之插入排序
	insertSort(arr2);
	printArray(arr2);
	// 数组的排序之选择排序
	selectSort(arr2);
	printArray(arr2);
	// 数组的查找之折半查找
	// 因为折半查找要求数组必须有序，所以先进行排序
	selectSort(arr2);
	int m = halfSearch(arr2,7);	
	System.out.println(m);	// 返回查找的数组下标，如果没有找到返回-1
	}
	// 打印数组
	public static void printArray(int[] y){
		for(int i =0; i < y.length; i++)
		{
			System.out.print(y[i]+"\t");
		}
		System.out.println();
	}
	// 获取数组中的最大值
	public static int getArrayMax(int[] y){
		int max = y[0];
		for(int i = 0; i < y.length; i++){
			if(y[i]>max){
				max =y[i];
			}
		}
		return max;	
	}
	//获取数组中的最小值
	public static int getArrayMin(int[] y){
		int min = y[0];
		for(int i = 0; i < y.length; i++){
			if(y[i]<min){
				min =y[i];
			}
		}
		return min;	
	}
	// 数组的排序之冒泡排序
	public static void bubbleSort(int[] y) {
		/**
		冒泡排序
		比较相邻的元素。如果第一个比第二个大，就交换他们两个。 [1] 
		对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 [1] 
		针对所有的元素重复以上的步骤，除了最后一个。 [1] 
		持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
		**/
		int temp = 0;
		// 外层循环，它决定一共走几趟
		for (int i = 0; i < y.length-1; ++i) {
		//内层循环，它决定每趟走一次
		for (int j = 0; j < y.length-i-1; ++j) {
		//如果后一个大于前一个  	换位
		if (y[j + 1] < y[j]) {
			temp = y[j];
			y[j] = y[j + 1];
			y[j + 1] = temp;
			}
		}	
	 }
	}
	// 数组的排序之插入排序
	public static void insertSort(int y[]) {
		int i, j;
		for (i = 1; i < y.length; i++) {
		int temp = y[i];
		for (j = i; j > 0 && temp < y[j - 1]; j--) {
		y[j] = y[j - 1];
		}
		y[j] = temp;
		}
		}
	// 数组的排序之选择排序
	public static void selectSort(int y[]) {
		int temp = 0;
		for (int i = 0; i < y.length - 1; i++) {
		// 认为目前的数就是最小的, 记录最小数的下标
		int minIndex = i;
		for (int j = i + 1; j < y.length; j++) {
		if (y[minIndex] > y[j]) {
		// 修改最小值的下标
		minIndex = j;
		}
		}
		// 当退出for就找到这次的最小值
		if (i != minIndex) {
		temp = y[i];
		y[i] = y[minIndex];
		y[minIndex] = temp;
		   }
		}
	}
	// 数组的查找之折半查找
	public static int halfSearch(int[] arr,int target) {
		//定义三个变量分别记录最大、最小、中间的查找范围索引值
		int max=arr.length-1;
		int min=0;
		int mid=(max+min)/2;
		while(true) {	
			if(target<arr[mid]) {		//如果目标元素小于中点元素
				max = mid-1;			//max向mid前移动
			}else if(target>arr[mid]) { //如果目标元素大于中点元素
				min = mid+1;			//min向mid后移动
			}else {
				return mid;				//找到目标元素
			}			
			//没有找到的情况
			if(max<min) {
				return -1;
			}			
			//重新计算中间索引值
			mid=(max+min)/2;
		}		
	}	
}
```

#### Javadoc 使用详解

https://blog.csdn.net/vbirdbest/article/details/80296136

## 面向对象

### 方法

#### 方法的概念

方法就是定义在类中的具有特定功能的一段独立代码（函数==方法）

方法的优点

- 减少代码冗余。
- 提高复用性。
- 提高可读性。
- 提高可维护性。
- 方便分工合作。

#### 方法的定义

```
修饰符 返回值类型 方法名（[参数类型1 参数名1,参数类型2 参数名2 ....]）{
    代码块.......
    return  返回值；    //返回值的类型必须与返回值类型一致
}
```

#### 方法的参数

形参：等同于局部变量
实参：

```
定义语法：
public static void 方法名称(形式参数){
      // 方法主体
}
调用语法
 方法名称(实际参数);
```

#### 方法的返回值与返回值类型

```
定义语法
public static 返回值类型 方法名称(形式参数列表){
        // 函数主体
    return value; // 返回值
}
调用语法
变量 = 方法名称();   // 变量类型与返回值类型一致
```

return关键字

- 用途
  （1）返回方法指定类型的值（前提是方法的返回值类型不是void）。
  （2）方法的结束，它会导致当前的方法退出。
- 使用形式
  （1）方法有返回值类型，格式：
                return 返回值;
  （2）方法没返回值类型，格式：
                return;

#### 方法的重载

在同一个类中，定义多个方法名相同、参数列表不同的方法。
调用时通过方法名和参数列表来确定一个方法,方法的重载和返回值类型无关。

```
public class Function_test {
    public static void main(String[] args) {
        // TODO Auto-generated method stub
            int a = add(4,9);
            System.out.println(a);
            int b = add(4,9,4);
            System.out.println(b);
    }

    // add函数，获取两个值的和
    public static int add(int x,int y){
            int sum = x+y;
            return sum;
    }

    // add函数的重载 ,获取三个值的和
    public static int add(int x,int y,int z){
        int sum = x+y+z;
        return sum;
    }
}
```

#### 方法的递归

函数的内部调用自身的过程

```
// 斐波那契数列
public class RecursionFibonacci {
public static void main(String[] args) {
	// 1 1 2 3 5 8 13 21 34 55 89
	Scanner sc = new Scanner(System.in);
	System.out.println("请输入fibonacci的项数：");
	int inpu = sc.nextInt();	
	int result = fibonacci(inpu);
	System.out.println(result);
}
public static int  fibonacci(int n){
	if (n == 0){
		return 0;
	}else if(n==1) {
		return 1;
	}
	return fibonacci(n-1)+fibonacci(n-2);
	}
}
```

递归输出文件目录名

```
public class RecursionFileName {   
public static void main(String[] args) {
        String path = "D:/";                   // 设定文件路径
        test(path);
    }
    private static void test(String path) {			// 输出文件目录函数
        File f = new File(path);				// 创建一个文件路径对象
        File[] fs = f.listFiles();				// 创建文件路径列表的数组
        if (fs == null) {						// if数组为空，则返回
            return;
        }
        for (File file : fs) {					// 输出数组
            if (file.isFile()) {
                System.out.println(file.getPath());
            } else {
                test(file.getPath());
            }
        }
    }
}
```

### 构造方法

> https://bbs.huaweicloud.com/blogs/308778
>
> 
>
> https://bbs.huaweicloud.com/blogs/311916



### 初始化

#### 类初始化

#### 成员初始化

#### 构造方法初始化

#### 初始化顺序

#### 数组初始化

### 封装

### 继承

### 多态

### 关键字

# 框架

## java框架

### SpringBoot

#### Spring Validation的使用

> https://jishuin.proginn.com/p/763bfbd6f5d5

### SpringCloud

#### SpringCloud问题

> https://mp.weixin.qq.com/s/xHJCQt97RNdGrf0VnTT_kA

# 中间件

## 数据库

### MySQL

#### MySQL replace()字符串替换函数的使用

> https://www.cnblogs.com/kegui/p/16642909.html

- 

### SQL优化

#### 1、explain

##### Extra

- using index：SQL所需要的返回值所有列数据均在一颗索引树上，即无需访问实际的行记录
- using where：SQL使用了where过滤条件

注：使用了where条件的SQL，并不代表不需要优化，需要进一步判断explain执行计划中type的类型，如果type为all，表示进行了全表扫描，则需要优化，否则不需要优化

- using index condition：说明检索确实命中索引，但不是所有的列都在索引树上，还有需要访问实际的行记录，这个SQL语句性能也很高，但不如using index
- using filesort：得到的所有的结果集，需要进行文件排序，SQL语句性能很差，需要优化

##### select_type

- SIMPLE(简单查询。查询不包含子查询和union)
- PRIMARY(子查询中最外层查询，查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY)
-  UNION(UNION中的第二个或后面的SELECT语句)
-  DEPENDENT UNION(UNION中的第二个或后面的SELECT语句，取决于外面的查询)
-  UNION RESULT(UNION的结果，union语句中第二个select开始后面所有select)
- SUBQUERY(子查询中的第一个SELECT，结果不依赖于外部查询)
- DEPENDENT SUBQUERY(子查询中的第一个SELECT，依赖于外部查询)
- DERIVED(派生表的SELECT, FROM子句的子查询)
-  UNCACHEABLE SUBQUERY(一个子查询的结果不能被缓存，必须重新评估外链接的第一行)

##### Table

这一列表示 explain 的一行正在访问哪个表

##### possible_keys 和 key

possible_keys这一列显示查询可能使用哪些索引来查找，key是真正使用的索引。
explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。 如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。

##### type

- system：表仅有一行，基本用不到；
- const：表最多一行数据配合，主键查询时触发较多；
- eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型；
- ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取；
- range：只检索给定范围的行，使用一个索引来选择行。当使用=、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range；

- index：该联接类型与ALL相同，除了只有索引树被扫描。这通常比ALL快，因为索引文件通常比数据文件小；

- all：全表扫描；

- 性能排名：system > const > eq_ref > ref > range > index > all。

- 实际sql优化中，最后达到ref或range级别。

#### 2、避免在where子句中使用 or 来连接条件

反例

```
SELECT * FROM user WHERE id=1 OR salary=5000
```

正例

使用union all或者分两条SQL写

```
SELECT * FROM user WHERE id=1 
UNION ALL
SELECT * FROM user WHERE salary=5000

SELECT * FROM user WHERE id=1
SELECT * FROM user WHERE salary=5000
```

使用`or`可能会使索引失效，从而全表扫描；

对于`or`没有索引的`salary`这种情况，假设它走了`id`的索引，但是走到`salary`查询条件时，它还得全表扫描；

也就是说整个过程需要三步：全表扫描+索引扫描+合并。如果它一开始就走全表扫描，直接一遍扫描就搞定；

虽然`mysql`是有优化器的，出于效率与成本考虑，遇到`or`条件，索引还是可能失效的；

#### 3、使用数值替代字符串类型

- 因为引擎在处理查询和连接时会逐个比较字符串中每一个字符；

- 而对于数字型而言只需要比较一次就够了；

- 字符会降低查询和连接的性能，并会增加存储开销；

#### 4、使用varchar代替char

- varchar`变长字段按数据内容实际长度存储，存储空间小，可以节省存储空间；

- char`按声明大小存储，不足补空格；

- 其次对于查询来说，在一个相对较小的字段内搜索，效率更高；

#### 5、避免在where子句中使用!=或<>操作符

- 使用`!=`和`<>`很可能会让索引失效

- 应尽量避免在`where`子句中使用`!=`或`<>`操作符，否则引擎将放弃使用索引而进行全表扫描

- 实现业务优先，实在没办法，就只能使用，并不是不能使用

#### 6、提高group by语句的效率

先过滤，后分组，可以在执行到该语句前，把不需要的记录过滤掉

```
SELECT
	job， avg（ salary） 
FROM
	employee 
WHERE
	job = 'develop'
GROUP BY job;
```

#### 7、优化like语句

```
select * from citys where name like '大连%' (使用索引) 。
```

- 首先尽量避免模糊查询，如果必须使用，不采用全模糊查询，也应尽量采用右模糊查询， 即`like ‘…%’`，是会使用索引的；
- 左模糊`like ‘%...’`无法直接使用索引，但可以利用`reverse + function index`的形式，变化成 `like ‘…%’`；
- 全模糊查询是无法优化的，一定要使用的话建议使用搜索引擎。

#### 8、查询SQL尽量不要使用select \*，而是具体字段

```
SELECT
	id, username,phone 
FROM
	tb_sys_org
```















































# 数据结构和算法

# 设计和结构

## 设计模式

## 架构

### 8种架构

> https://mp.weixin.qq.com/s/per0sigoPNTMYRr4oN1AVw

# 运维

# 分布式

# 工具

## GitHub

### 本地项目上传到github

#### 创建仓库

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20220829_112143.png)

#### 配置SSH Key

如果没有配置github，需要配置

#### 本地项目初始化

![](https://kegui.oss-cn-hangzhou.aliyuncs.com/xiao/xiao_20220829_112628.png)

#### 在终端下关联git仓库

运行：**git remote add origin git@github.com:【你的github用户名】/【仓库名称】.git**，例如`git remote add origin git@github.com:itmacy/cloud-note.git`

```
xiao@xiao MINGW64 /f/读书破万卷/xiao (master)
$  git remote add origin git@github.com:xiao2769433/xiao.git
```

#### 代码提交

- 把本地所有文件添加到缓冲区，运行：`git add .`
- 提交所有文件，运行：`git commit -m ‘添加项目’`
- 推送到git仓库，运行：`git push —set-upstream origin master`

## IDEA

### IDEA官网

> https://www.jetbrains.com/idea/

### IDEA断点调试技巧

> https://blog.51cto.com/u_15454291/5341117