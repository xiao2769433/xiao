

## 第一章 算法简介

### 二分查找

- 查询速度是非常快的，比较次数少，平均性能好。
- 缺点就是二分查找必须有个前提就是数组是有序的，而且插入删除都比较困难。

```
    /**
     * Arrays类的binarySearch方法
     * 如果需要查找的数据存在，就返回数组中对应数据的下标值，
     * 如果不存在，返回值为：-（应该插入的位置索引+1）
     *
     * @param array     有序数组
     * @param searchNum 查找的数
     * @return 查找的数的下标
     */
    public static int binarySearch(int[] array, int searchNum) {
        return Arrays.binarySearch(array, searchNum);
    }

    /**
     * 迭代方式
     *
     * @param array     有序数组
     * @param searchNum 查找的数
     * @return 查找的数的下标
     */
    public static int binarySearchIteration(int[] array, int searchNum) {
        //初始化最小值的索引为0
        int left = 0;
        //初始化最大值的索引为arr.length-1
        int right = array.length - 1;
        //首尾相加再除以2得出中间索引
        int mid = (left + right) / 2;
        while (left <= right) { //确保程序不会重复查询，不会越界
            if (searchNum > array[mid]) {
                //如果查询的值比中间值大，则往右边区域找，就把最小索引改为中间索引右移一位
                left = mid + 1;
            } else if (searchNum < array[mid]) {
                //如果查询的值比中间值小，则往左边区域找，就把最大索引改为中间索引左移一位
                right = mid - 1;
            } else {
                //剩余的情况就是查询到了结果，那么就直接返回索引。
                return mid;
            }
            mid = (left + right) / 2;
        }
        //没有查询到，则返回-1
        return -1;
    }

    /**
     * 递归方式
     *
     * @param array     有序数组
     * @param searchNum 查找的数
     * @return 查找的数的下标
     */
    public static int binarySearchRecursion(int[] array, int searchNum) {
        //初始化最小值的索引为0
        int left = 0;
        //初始化最大值的索引为arr.length-1
        int right = array.length - 1;
        if (left > right) {
            return -1;
        }
        int mid = (left + right) / 2;
        if (array[mid] == searchNum) {
            return mid;
        } else if (array[mid] > searchNum) {
            return binarySearchRecursion(array, mid - 1);
        } else {
            return binarySearchRecursion(array, searchNum);
        }
    }
```

## 第二章 选择排序

### 数组和链表

> https://www.cnblogs.com/54chensongxia/p/11474539.html

### 选择排序

```
public static void selectSort(int[] array, int index) {
        for (int i = 0; i < array.length - 1; i++) {
            for (int j = i + 1; j < array.length - 1; j++) {
                if (array[j] < array[index]) {
                    index = j;
                }
            }
            if (index != i) {
                swap(array, i, index);
            }
        }
    }

    /**
     * 交换位置
     */
    public static void swap(int[] sortArray, int start, int end) {
        int temp = sortArray[start];
        sortArray[start] = sortArray[end];
        sortArray[end] = temp;
    }
```

## 第三章 递归

### 栈

> https://blog.csdn.net/weixin_53227758/article/details/123000527

## 第四章 快速排序

### 分而治之



## 第五章 散列表

### 散列函数

### 冲突

### 性能



## 第六章 广度优先搜索



> https://blog.csdn.net/qq_41966475/article/details/108909311





## 第七章 狄克斯特拉算法

> https://blog.csdn.net/afei__/article/details/83352205
>
> https://blog.csdn.net/qq_34842671/article/details/90083037



## 第8章 贪婪算法



## 第9章 动态规划



## 第10章 K最近邻算法







## 练习

### 第一章 算法简介

#### 二分查找
- 1.1 假设有一个包含128个名字的有序列表，你要使用二分查找在其中查找一个名字，请问最多需要几步才能找到？
```
log 2^128=7步
```

- 1.2 上面列表的长度翻倍后，最多需要几步？
```
log 2^256=8步
```

#### 大O表示
- 1.3 在电话簿中根据名字查找电话号码。
```
二分查找，为O(log2^n)
```

- 1.4 在电话簿中根据电话号码找人。（提示：你必须查找整个电话簿。）
```
O(n)
```

- 1.5 阅读电话簿中每个人的电话号码。
```
O(n)
```

- 1.6 阅读电话簿中姓名以A打头的人的电话号码。这个问题比较棘手，它涉及第4章的概念。答案可能让你感到惊讶！
```
O(n)
```


### 第二章 选择排序
#### 数组和链表
- 2.1 假设你要编写一个记账的应用程序。
  - 1.卖杂货
  - 2.看电影
  - 3.会费

你每天都将所有的支出记录下来，并在月底统计支出，算算当月花了多少钱。因此，你执行的插入操作很多，但读取操作很少。该使用数组还是链表呢？

```
每天都在列表中添加支出项，但每月只读取支出一次。而数组的读取速度很快，但插入速度慢；链表的读取速度慢，但插入速度快。因为我们执行的插入操作比读取操作多，因此使用链表合适。
```

- 2.2 假设你要为饭店创建一个接受顾客点菜单的应用程序。这个应用程序存储一系列点菜单。服务员添加点菜单，而厨师取出点菜单并制作菜肴。这是一个点菜单队列：服务员在队尾添加点菜单，厨师取出队列开头的点菜单并制作菜肴。

  你使用数组还是链表来实现这个队列呢？（提示：链表擅长插入和删除，而数组擅长随机访问。在这个应用程序中，你要执行的是哪些操作呢？）

```
经常要执行插入操作——服务员添加点菜单，而链表的插入速度很快；而且不需要执行查找和随机访问操作（这是数组擅长的），因为厨师总是从队列中取出第一个点菜单。综上所述，使用链表合适。
```

- 2.3 我们来做一个思考实验。假设Facebook记录一系列用户名，每当有用户试图登录Facebook时，都查找其用户名，如果找到就允许用户登录。由于经常有用户登录Facebook，因此需要执行大量的用户名查找操作。假设Facebook使用二分查找算法，而这种算法要求能够随机访问——立即获取中间的用户名。考虑到这一点，应使用数组还是链表来存储用户名呢？

```
有序数组。数组让你能够随机访问从而立即获取数组中间的元素，而使用链表无法这样操作。要获取链表中间的元素，就必须从第一个元素开始，沿链接逐渐找到这个元素。
```

- 2.4 经常有用户在Facebook注册。假设你已决定使用数组来存储用户名，在插入方面数组有何缺点呢？具体地说，在数组中添加新用户将出现什么情况？

```
数组的插入速度很慢。另外如果要使用二分查找算法来查找用户名，数组必须是有序的，因此每次插入用户名后，都必须对数组进行排序。
```

- 2.5 实际上，Facebook存储用户信息时使用的既不是数组也不是链表。假设Facebook使用的是一种混合数据：链表数组。这个数组包含26个元素，每个元素都指向一个链表。例如，该数组的第一个元素指向的链表包含所有以A打头的用户名，第二个元素指向的链表包含所有以B打头的用户名，以此类推。

  假设Adit B在Facebook注册，而你需要将其加入前述数据结构中。因此，你访问数组的第一个元素，再访问该元素指向的链表，并将Adit B添加到这个链表末尾。现在假设你要查找Zakhir H。因此你访问第26个元素，再在它指向的链表（该链表包含所有以z打头的用户名）中查找Zakhir H。请问，相比于数组和链表，这种混合数据结构的查找和插入速度更慢还是更快？你不必给出大O运行时间，只需指出这种新数据结构的查找和插入速度更快还是更慢。

```
查找时，其速度比数组慢，但比链表快；而在插入时，其速度比数组快，但与链表相当。因此，除了查找速度比数组慢，其他方面并不比链表慢。
```

### 第三章 递归

- 3.2 假设你编写了一个递归函数，但不小心导致它没完没了地运行。正如你看到的，对于每次函数调用，计算机都将为其在栈中分配内存。递归函数没完没了地运行时，将给栈带来什么影响？

```
调用栈不断加层，会越来越长，直至计算机内存不够,溢出
```

### 第四章 快速排序

#### 分而治之

- 4.1 请编写前述sum函数的代码。

```
public class QuestionOne {
    public static void main(String[] args) {
        int[] array = {1, 2, 3, 4, 5, 6, 7, 8, 9, 11};
        System.out.println(loopSum(array));
        System.out.println(recursionSum(array, array.length - 1));
    }

    /**
     * 遍历方式
     */
    public static int loopSum(int[] array) {
        int sum = 0;
        for (int i = 0; i < array.length; i++) {
            sum += array[i];
        }
        return sum;
    }

    /**
     * 递归方式
     */
    public static int recursionSum(int[] arr, int n) {
        //基线条件
        if (n == 0) {
            return arr[n];
        } else {
            return arr[n] + recursionSum(arr, n - 1);
        }
    }
}
```

- 4.2 编写一个递归函数来计算列表包含的元素数。

```
 	/*
     * 计算列表所包含的元素数
     */
    public static int countNumbers(int[] arr, int n) {
        //判断数组是否为空
        if (arr.length == 0) {
            return 0;
        }
        //基线条件
        else if (n == 0) {
            return 1;
        } else {
            return 1 + countNumbers(arr, n - 1);
        }
    }
```

- 4.3 找出列表中最大的数字。

```
	public static int findMax(int[] arr, int leftIndex, int rightIndex) {
        // 基线条件
        if (leftIndex == rightIndex) {
            return arr[leftIndex];
        }
        // 这种方式求得mid不会溢出
        int mid = leftIndex + (rightIndex - leftIndex) / 2;
        int maxLeft = findMax(arr, leftIndex, mid);
        int maxRight = findMax(arr, mid + 1, rightIndex);

        return Math.max(maxLeft, maxRight);
    }
```

- 4.4 还记得第1章介绍的二分查找吗？它也是一种分而治之算法。你能找出二分查找算法的基线条件和递归条件吗？

```
基线条件：数组中仅剩一个元素（是否为查找元素为另外的判断，不属于基线条件之内）

递归条件：将数组分为两部分，如果查找值比第一部分的最大值小，则对第一部分继续二分查找，否则对剩余部分进行二分查找。
```

#### 再谈大O表示法

**使用大O表示法时，下面各种操作都需要多长时间？**

- 4.5 打印数组中每个元素的值。

```
O(n)
```

- 4.6 将数组中每个元素的值都乘以2。

```
O(n)
```

- 4.7 只将数组中第一个元素的值乘以2。

```
O(1)
```

- 4.8 根据数组包含的元素创建一个乘法表，即如果数组为[2, 3, 7, 8, 10]，首先将每个元素都乘以2，再将每个元素都乘以3，然后将每个元素都乘以7，以此类推。

```
n个元素做n次乘法操作。故为O(n^2)  。
```

### 第五章 散列表

- 5.1 f(x) = 1 ←（无论输入是什么，都返回1）

```
一致，对于同样的输入，散列表返回相同的值1。
```

- 5.2 f(x) = rand() ← （每次都返回一个随机数）

```
不一致，对于同样的输入，散列表可能返回不同的随机数。
```

- 5.3 f(x) = next_empty_slot() ← （返回散列表中下一个空位置的索引）

```
不一致，对于相同的输入，散列表返回下一个空位置的索引，而下一个空位置的索引随时可能变化。
```

- 5.4 f(x) = len(x) ← （将字符串的长度用作索引）

```
一致，对于相同的输入，散列表返回的始终是该输入字符串的长度。
```

